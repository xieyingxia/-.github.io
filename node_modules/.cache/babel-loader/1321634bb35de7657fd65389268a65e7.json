{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\n\nvar jsx = function () {\n  var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  return function createRawReactElement(type, props, key, children) {\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {};\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  };\n}();\n\nvar asyncToGenerator = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            return step(\"next\", value);\n          }, function (err) {\n            return step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineEnumerableProperties = function (obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  return obj;\n};\n\nvar defaults = function (obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n};\n\nvar defineProperty$1 = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar _instanceof = function (left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n};\n\nvar interopRequireDefault = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n};\n\nvar interopRequireWildcard = function (obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n};\n\nvar newArrowCheck = function (innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n};\n\nvar objectDestructuringEmpty = function (obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar selfGlobal = typeof global === \"undefined\" ? self : global;\n\nvar set = function set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar slicedToArrayLoose = function (arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n};\n\nvar taggedTemplateLiteral = function (strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n};\n\nvar taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\nvar temporalRef = function (val, name, undef) {\n  if (val === undef) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n};\n\nvar temporalUndefined = {};\n\nvar toArray = function (arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar babelHelpers$1 = Object.freeze({\n  jsx: jsx,\n  asyncToGenerator: asyncToGenerator,\n  classCallCheck: classCallCheck,\n  createClass: createClass,\n  defineEnumerableProperties: defineEnumerableProperties,\n  defaults: defaults,\n  defineProperty: defineProperty$1,\n  get: get,\n  inherits: inherits,\n  interopRequireDefault: interopRequireDefault,\n  interopRequireWildcard: interopRequireWildcard,\n  newArrowCheck: newArrowCheck,\n  objectDestructuringEmpty: objectDestructuringEmpty,\n  objectWithoutProperties: objectWithoutProperties,\n  possibleConstructorReturn: possibleConstructorReturn,\n  selfGlobal: selfGlobal,\n  set: set,\n  slicedToArray: slicedToArray,\n  slicedToArrayLoose: slicedToArrayLoose,\n  taggedTemplateLiteral: taggedTemplateLiteral,\n  taggedTemplateLiteralLoose: taggedTemplateLiteralLoose,\n  temporalRef: temporalRef,\n  temporalUndefined: temporalUndefined,\n  toArray: toArray,\n  toConsumableArray: toConsumableArray,\n  typeof: _typeof,\n  extends: _extends,\n  instanceof: _instanceof\n});\n\nvar realDefineProp = function () {\n  var sentinel = function sentinel() {};\n\n  try {\n    Object.defineProperty(sentinel, 'a', {\n      get: function get() {\n        return 1;\n      }\n    });\n    Object.defineProperty(sentinel, 'prototype', {\n      writable: false\n    });\n    return sentinel.a === 1 && sentinel.prototype instanceof Object;\n  } catch (e) {\n    return false;\n  }\n}(); // Need a workaround for getters in ES3\n\n\nvar es3 = !realDefineProp && !Object.prototype.__defineGetter__; // We use this a lot (and need it for proto-less objects)\n\nvar hop = Object.prototype.hasOwnProperty; // Naive defineProperty for compatibility\n\nvar defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n  if ('get' in desc && obj.__defineGetter__) obj.__defineGetter__(name, desc.get);else if (!hop.call(obj, name) || 'value' in desc) obj[name] = desc.value;\n}; // Array.prototype.indexOf, as good as we need it to be\n\nvar arrIndexOf = Array.prototype.indexOf || function (search) {\n  /*jshint validthis:true */\n  var t = this;\n  if (!t.length) return -1;\n\n  for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n    if (t[i] === search) return i;\n  }\n\n  return -1;\n}; // Create an object with the specified prototype (2nd arg required for Record)\n\n\nvar objCreate = Object.create || function (proto, props) {\n  var obj = void 0;\n\n  function F() {}\n\n  F.prototype = proto;\n  obj = new F();\n\n  for (var k in props) {\n    if (hop.call(props, k)) defineProperty(obj, k, props[k]);\n  }\n\n  return obj;\n}; // Snapshot some (hopefully still) native built-ins\n\n\nvar arrSlice = Array.prototype.slice;\nvar arrConcat = Array.prototype.concat;\nvar arrPush = Array.prototype.push;\nvar arrJoin = Array.prototype.join;\nvar arrShift = Array.prototype.shift; // Naive Function.prototype.bind for compatibility\n\nvar fnBind = Function.prototype.bind || function (thisObj) {\n  var fn = this,\n      args = arrSlice.call(arguments, 1); // All our (presently) bound functions have either 1 or 0 arguments. By returning\n  // different function signatures, we can pass some tests in ES3 environments\n\n  if (fn.length === 1) {\n    return function () {\n      return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n    };\n  }\n\n  return function () {\n    return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n  };\n}; // Object housing internal properties for constructors\n\n\nvar internals = objCreate(null); // Keep internal properties internal\n\nvar secret = Math.random(); // Helper functions\n// ================\n\n/**\n * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n * causing issue #62.\n */\n\nfunction log10Floor(n) {\n  // ES6 provides the more accurate Math.log10\n  if (typeof Math.log10 === 'function') return Math.floor(Math.log10(n));\n  var x = Math.round(Math.log(n) * Math.LOG10E);\n  return x - (Number('1e' + x) > n);\n}\n/**\n * A map that doesn't contain Object in its prototype chain\n */\n\n\nfunction Record(obj) {\n  // Copy only own properties over unless this object is already a Record instance\n  for (var k in obj) {\n    if (obj instanceof Record || hop.call(obj, k)) defineProperty(this, k, {\n      value: obj[k],\n      enumerable: true,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nRecord.prototype = objCreate(null);\n/**\n * An ordered list\n */\n\nfunction List() {\n  defineProperty(this, 'length', {\n    writable: true,\n    value: 0\n  });\n  if (arguments.length) arrPush.apply(this, arrSlice.call(arguments));\n}\n\nList.prototype = objCreate(null);\n/**\n * Constructs a regular expression to restore tainted RegExp properties\n */\n\nfunction createRegExpRestore() {\n  if (internals.disableRegExpRestore) {\n    return function () {\n      /* no-op */\n    };\n  }\n\n  var regExpCache = {\n    lastMatch: RegExp.lastMatch || '',\n    leftContext: RegExp.leftContext,\n    multiline: RegExp.multiline,\n    input: RegExp.input\n  },\n      has = false; // Create a snapshot of all the 'captured' properties\n\n  for (var i = 1; i <= 9; i++) {\n    has = (regExpCache['$' + i] = RegExp['$' + i]) || has;\n  }\n\n  return function () {\n    // Now we've snapshotted some properties, escape the lastMatch string\n    var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n        lm = regExpCache.lastMatch.replace(esc, '\\\\$&'),\n        reg = new List(); // If any of the captured strings were non-empty, iterate over them all\n\n    if (has) {\n      for (var _i = 1; _i <= 9; _i++) {\n        var m = regExpCache['$' + _i]; // If it's empty, add an empty capturing group\n\n        if (!m) lm = '()' + lm; // Else find the string in lm and escape & wrap it to capture it\n        else {\n            m = m.replace(esc, '\\\\$&');\n            lm = lm.replace(m, '(' + m + ')');\n          } // Push it to the reg and chop lm to make sure further groups come after\n\n        arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n        lm = lm.slice(lm.indexOf('(') + 1);\n      }\n    }\n\n    var exprStr = arrJoin.call(reg, '') + lm; // Shorten the regex by replacing each part of the expression with a match\n    // for a string of that exact length.  This is safe for the type of\n    // expressions generated above, because the expression matches the whole\n    // match string, so we know each group and each segment between capturing\n    // groups can be matched by its length alone.\n\n    exprStr = exprStr.replace(/(\\\\\\(|\\\\\\)|[^()])+/g, function (match) {\n      return '[\\\\s\\\\S]{' + match.replace('\\\\', '').length + '}';\n    }); // Create the regular expression that will reconstruct the RegExp properties\n\n    var expr = new RegExp(exprStr, regExpCache.multiline ? 'gm' : 'g'); // Set the lastIndex of the generated expression to ensure that the match\n    // is found in the correct index.\n\n    expr.lastIndex = regExpCache.leftContext.length;\n    expr.exec(regExpCache.input);\n  };\n}\n/**\n * Mimics ES5's abstract ToObject() function\n */\n\n\nfunction toObject(arg) {\n  if (arg === null) throw new TypeError('Cannot convert null or undefined to object');\n  if ((typeof arg === 'undefined' ? 'undefined' : babelHelpers$1['typeof'](arg)) === 'object') return arg;\n  return Object(arg);\n}\n\nfunction toNumber(arg) {\n  if (typeof arg === 'number') return arg;\n  return Number(arg);\n}\n\nfunction toInteger(arg) {\n  var number = toNumber(arg);\n  if (isNaN(number)) return 0;\n  if (number === +0 || number === -0 || number === +Infinity || number === -Infinity) return number;\n  if (number < 0) return Math.floor(Math.abs(number)) * -1;\n  return Math.floor(Math.abs(number));\n}\n\nfunction toLength(arg) {\n  var len = toInteger(arg);\n  if (len <= 0) return 0;\n  if (len === Infinity) return Math.pow(2, 53) - 1;\n  return Math.min(len, Math.pow(2, 53) - 1);\n}\n/**\n * Returns \"internal\" properties for an object\n */\n\n\nfunction getInternalProperties(obj) {\n  if (hop.call(obj, '__getInternalProperties')) return obj.__getInternalProperties(secret);\n  return objCreate(null);\n}\n/**\n* Defines regular expressions for various operations related to the BCP 47 syntax,\n* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n*/\n// extlang       = 3ALPHA              ; selected ISO 639 codes\n//                 *2(\"-\" 3ALPHA)      ; permanently reserved\n\n\nvar extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}'; // language      = 2*3ALPHA            ; shortest ISO 639 code\n//                 [\"-\" extlang]       ; sometimes followed by\n//                                     ; extended language subtags\n//               / 4ALPHA              ; or reserved for future use\n//               / 5*8ALPHA            ; or registered language subtag\n\nvar language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})'; // script        = 4ALPHA              ; ISO 15924 code\n\nvar script = '[a-z]{4}'; // region        = 2ALPHA              ; ISO 3166-1 code\n//               / 3DIGIT              ; UN M.49 code\n\nvar region = '(?:[a-z]{2}|\\\\d{3})'; // variant       = 5*8alphanum         ; registered variants\n//               / (DIGIT 3alphanum)\n\nvar variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})'; //                                     ; Single alphanumerics\n//                                     ; \"x\" reserved for private use\n// singleton     = DIGIT               ; 0 - 9\n//               / %x41-57             ; A - W\n//               / %x59-5A             ; Y - Z\n//               / %x61-77             ; a - w\n//               / %x79-7A             ; y - z\n\nvar singleton = '[0-9a-wy-z]'; // extension     = singleton 1*(\"-\" (2*8alphanum))\n\nvar extension = singleton + '(?:-[a-z0-9]{2,8})+'; // privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\n\nvar privateuse = 'x(?:-[a-z0-9]{1,8})+'; // irregular     = \"en-GB-oed\"         ; irregular tags do not match\n//               / \"i-ami\"             ; the 'langtag' production and\n//               / \"i-bnn\"             ; would not otherwise be\n//               / \"i-default\"         ; considered 'well-formed'\n//               / \"i-enochian\"        ; These tags are all valid,\n//               / \"i-hak\"             ; but most are deprecated\n//               / \"i-klingon\"         ; in favor of more modern\n//               / \"i-lux\"             ; subtags or subtag\n//               / \"i-mingo\"           ; combination\n//               / \"i-navajo\"\n//               / \"i-pwn\"\n//               / \"i-tao\"\n//               / \"i-tay\"\n//               / \"i-tsu\"\n//               / \"sgn-BE-FR\"\n//               / \"sgn-BE-NL\"\n//               / \"sgn-CH-DE\"\n\nvar irregular = '(?:en-GB-oed' + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)' + '|sgn-(?:BE-FR|BE-NL|CH-DE))'; // regular       = \"art-lojban\"        ; these tags match the 'langtag'\n//               / \"cel-gaulish\"       ; production, but their subtags\n//               / \"no-bok\"            ; are not extended language\n//               / \"no-nyn\"            ; or variant subtags: their meaning\n//               / \"zh-guoyu\"          ; is defined by their registration\n//               / \"zh-hakka\"          ; and all of these are deprecated\n//               / \"zh-min\"            ; in favor of a more modern\n//               / \"zh-min-nan\"        ; subtag or sequence of subtags\n//               / \"zh-xiang\"\n\nvar regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn' + '|zh-(?:guoyu|hakka|min|min-nan|xiang))'; // grandfathered = irregular           ; non-redundant tags registered\n//               / regular             ; during the RFC 3066 era\n\nvar grandfathered = '(?:' + irregular + '|' + regular + ')'; // langtag       = language\n//                 [\"-\" script]\n//                 [\"-\" region]\n//                 *(\"-\" variant)\n//                 *(\"-\" extension)\n//                 [\"-\" privateuse]\n\nvar langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-' + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?'; // Language-Tag  = langtag             ; normal language tags\n//               / privateuse          ; private use tag\n//               / grandfathered       ; grandfathered tags\n\nvar expBCP47Syntax = RegExp('^(?:' + langtag + '|' + privateuse + '|' + grandfathered + ')$', 'i'); // Match duplicate variants in a language tag\n\nvar expVariantDupes = RegExp('^(?!x).*?-(' + variant + ')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i'); // Match duplicate singletons in a language tag (except in private use)\n\nvar expSingletonDupes = RegExp('^(?!x).*?-(' + singleton + ')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i'); // Match all extension sequences\n\nvar expExtSequences = RegExp('-' + extension, 'ig'); // Default locale is the first-added locale data for us\n\nvar defaultLocale = void 0;\n\nfunction setDefaultLocale(locale) {\n  defaultLocale = locale;\n} // IANA Subtag Registry redundant tag and subtag maps\n\n\nvar redundantTags = {\n  tags: {\n    \"art-lojban\": \"jbo\",\n    \"i-ami\": \"ami\",\n    \"i-bnn\": \"bnn\",\n    \"i-hak\": \"hak\",\n    \"i-klingon\": \"tlh\",\n    \"i-lux\": \"lb\",\n    \"i-navajo\": \"nv\",\n    \"i-pwn\": \"pwn\",\n    \"i-tao\": \"tao\",\n    \"i-tay\": \"tay\",\n    \"i-tsu\": \"tsu\",\n    \"no-bok\": \"nb\",\n    \"no-nyn\": \"nn\",\n    \"sgn-BE-FR\": \"sfb\",\n    \"sgn-BE-NL\": \"vgt\",\n    \"sgn-CH-DE\": \"sgg\",\n    \"zh-guoyu\": \"cmn\",\n    \"zh-hakka\": \"hak\",\n    \"zh-min-nan\": \"nan\",\n    \"zh-xiang\": \"hsn\",\n    \"sgn-BR\": \"bzs\",\n    \"sgn-CO\": \"csn\",\n    \"sgn-DE\": \"gsg\",\n    \"sgn-DK\": \"dsl\",\n    \"sgn-ES\": \"ssp\",\n    \"sgn-FR\": \"fsl\",\n    \"sgn-GB\": \"bfi\",\n    \"sgn-GR\": \"gss\",\n    \"sgn-IE\": \"isg\",\n    \"sgn-IT\": \"ise\",\n    \"sgn-JP\": \"jsl\",\n    \"sgn-MX\": \"mfs\",\n    \"sgn-NI\": \"ncs\",\n    \"sgn-NL\": \"dse\",\n    \"sgn-NO\": \"nsl\",\n    \"sgn-PT\": \"psr\",\n    \"sgn-SE\": \"swl\",\n    \"sgn-US\": \"ase\",\n    \"sgn-ZA\": \"sfs\",\n    \"zh-cmn\": \"cmn\",\n    \"zh-cmn-Hans\": \"cmn-Hans\",\n    \"zh-cmn-Hant\": \"cmn-Hant\",\n    \"zh-gan\": \"gan\",\n    \"zh-wuu\": \"wuu\",\n    \"zh-yue\": \"yue\"\n  },\n  subtags: {\n    BU: \"MM\",\n    DD: \"DE\",\n    FX: \"FR\",\n    TP: \"TL\",\n    YD: \"YE\",\n    ZR: \"CD\",\n    heploc: \"alalc97\",\n    'in': \"id\",\n    iw: \"he\",\n    ji: \"yi\",\n    jw: \"jv\",\n    mo: \"ro\",\n    ayx: \"nun\",\n    bjd: \"drl\",\n    ccq: \"rki\",\n    cjr: \"mom\",\n    cka: \"cmr\",\n    cmk: \"xch\",\n    drh: \"khk\",\n    drw: \"prs\",\n    gav: \"dev\",\n    hrr: \"jal\",\n    ibi: \"opa\",\n    kgh: \"kml\",\n    lcq: \"ppr\",\n    mst: \"mry\",\n    myt: \"mry\",\n    sca: \"hle\",\n    tie: \"ras\",\n    tkk: \"twm\",\n    tlw: \"weo\",\n    tnf: \"prs\",\n    ybd: \"rki\",\n    yma: \"lrr\"\n  },\n  extLang: {\n    aao: [\"aao\", \"ar\"],\n    abh: [\"abh\", \"ar\"],\n    abv: [\"abv\", \"ar\"],\n    acm: [\"acm\", \"ar\"],\n    acq: [\"acq\", \"ar\"],\n    acw: [\"acw\", \"ar\"],\n    acx: [\"acx\", \"ar\"],\n    acy: [\"acy\", \"ar\"],\n    adf: [\"adf\", \"ar\"],\n    ads: [\"ads\", \"sgn\"],\n    aeb: [\"aeb\", \"ar\"],\n    aec: [\"aec\", \"ar\"],\n    aed: [\"aed\", \"sgn\"],\n    aen: [\"aen\", \"sgn\"],\n    afb: [\"afb\", \"ar\"],\n    afg: [\"afg\", \"sgn\"],\n    ajp: [\"ajp\", \"ar\"],\n    apc: [\"apc\", \"ar\"],\n    apd: [\"apd\", \"ar\"],\n    arb: [\"arb\", \"ar\"],\n    arq: [\"arq\", \"ar\"],\n    ars: [\"ars\", \"ar\"],\n    ary: [\"ary\", \"ar\"],\n    arz: [\"arz\", \"ar\"],\n    ase: [\"ase\", \"sgn\"],\n    asf: [\"asf\", \"sgn\"],\n    asp: [\"asp\", \"sgn\"],\n    asq: [\"asq\", \"sgn\"],\n    asw: [\"asw\", \"sgn\"],\n    auz: [\"auz\", \"ar\"],\n    avl: [\"avl\", \"ar\"],\n    ayh: [\"ayh\", \"ar\"],\n    ayl: [\"ayl\", \"ar\"],\n    ayn: [\"ayn\", \"ar\"],\n    ayp: [\"ayp\", \"ar\"],\n    bbz: [\"bbz\", \"ar\"],\n    bfi: [\"bfi\", \"sgn\"],\n    bfk: [\"bfk\", \"sgn\"],\n    bjn: [\"bjn\", \"ms\"],\n    bog: [\"bog\", \"sgn\"],\n    bqn: [\"bqn\", \"sgn\"],\n    bqy: [\"bqy\", \"sgn\"],\n    btj: [\"btj\", \"ms\"],\n    bve: [\"bve\", \"ms\"],\n    bvl: [\"bvl\", \"sgn\"],\n    bvu: [\"bvu\", \"ms\"],\n    bzs: [\"bzs\", \"sgn\"],\n    cdo: [\"cdo\", \"zh\"],\n    cds: [\"cds\", \"sgn\"],\n    cjy: [\"cjy\", \"zh\"],\n    cmn: [\"cmn\", \"zh\"],\n    coa: [\"coa\", \"ms\"],\n    cpx: [\"cpx\", \"zh\"],\n    csc: [\"csc\", \"sgn\"],\n    csd: [\"csd\", \"sgn\"],\n    cse: [\"cse\", \"sgn\"],\n    csf: [\"csf\", \"sgn\"],\n    csg: [\"csg\", \"sgn\"],\n    csl: [\"csl\", \"sgn\"],\n    csn: [\"csn\", \"sgn\"],\n    csq: [\"csq\", \"sgn\"],\n    csr: [\"csr\", \"sgn\"],\n    czh: [\"czh\", \"zh\"],\n    czo: [\"czo\", \"zh\"],\n    doq: [\"doq\", \"sgn\"],\n    dse: [\"dse\", \"sgn\"],\n    dsl: [\"dsl\", \"sgn\"],\n    dup: [\"dup\", \"ms\"],\n    ecs: [\"ecs\", \"sgn\"],\n    esl: [\"esl\", \"sgn\"],\n    esn: [\"esn\", \"sgn\"],\n    eso: [\"eso\", \"sgn\"],\n    eth: [\"eth\", \"sgn\"],\n    fcs: [\"fcs\", \"sgn\"],\n    fse: [\"fse\", \"sgn\"],\n    fsl: [\"fsl\", \"sgn\"],\n    fss: [\"fss\", \"sgn\"],\n    gan: [\"gan\", \"zh\"],\n    gds: [\"gds\", \"sgn\"],\n    gom: [\"gom\", \"kok\"],\n    gse: [\"gse\", \"sgn\"],\n    gsg: [\"gsg\", \"sgn\"],\n    gsm: [\"gsm\", \"sgn\"],\n    gss: [\"gss\", \"sgn\"],\n    gus: [\"gus\", \"sgn\"],\n    hab: [\"hab\", \"sgn\"],\n    haf: [\"haf\", \"sgn\"],\n    hak: [\"hak\", \"zh\"],\n    hds: [\"hds\", \"sgn\"],\n    hji: [\"hji\", \"ms\"],\n    hks: [\"hks\", \"sgn\"],\n    hos: [\"hos\", \"sgn\"],\n    hps: [\"hps\", \"sgn\"],\n    hsh: [\"hsh\", \"sgn\"],\n    hsl: [\"hsl\", \"sgn\"],\n    hsn: [\"hsn\", \"zh\"],\n    icl: [\"icl\", \"sgn\"],\n    ils: [\"ils\", \"sgn\"],\n    inl: [\"inl\", \"sgn\"],\n    ins: [\"ins\", \"sgn\"],\n    ise: [\"ise\", \"sgn\"],\n    isg: [\"isg\", \"sgn\"],\n    isr: [\"isr\", \"sgn\"],\n    jak: [\"jak\", \"ms\"],\n    jax: [\"jax\", \"ms\"],\n    jcs: [\"jcs\", \"sgn\"],\n    jhs: [\"jhs\", \"sgn\"],\n    jls: [\"jls\", \"sgn\"],\n    jos: [\"jos\", \"sgn\"],\n    jsl: [\"jsl\", \"sgn\"],\n    jus: [\"jus\", \"sgn\"],\n    kgi: [\"kgi\", \"sgn\"],\n    knn: [\"knn\", \"kok\"],\n    kvb: [\"kvb\", \"ms\"],\n    kvk: [\"kvk\", \"sgn\"],\n    kvr: [\"kvr\", \"ms\"],\n    kxd: [\"kxd\", \"ms\"],\n    lbs: [\"lbs\", \"sgn\"],\n    lce: [\"lce\", \"ms\"],\n    lcf: [\"lcf\", \"ms\"],\n    liw: [\"liw\", \"ms\"],\n    lls: [\"lls\", \"sgn\"],\n    lsg: [\"lsg\", \"sgn\"],\n    lsl: [\"lsl\", \"sgn\"],\n    lso: [\"lso\", \"sgn\"],\n    lsp: [\"lsp\", \"sgn\"],\n    lst: [\"lst\", \"sgn\"],\n    lsy: [\"lsy\", \"sgn\"],\n    ltg: [\"ltg\", \"lv\"],\n    lvs: [\"lvs\", \"lv\"],\n    lzh: [\"lzh\", \"zh\"],\n    max: [\"max\", \"ms\"],\n    mdl: [\"mdl\", \"sgn\"],\n    meo: [\"meo\", \"ms\"],\n    mfa: [\"mfa\", \"ms\"],\n    mfb: [\"mfb\", \"ms\"],\n    mfs: [\"mfs\", \"sgn\"],\n    min: [\"min\", \"ms\"],\n    mnp: [\"mnp\", \"zh\"],\n    mqg: [\"mqg\", \"ms\"],\n    mre: [\"mre\", \"sgn\"],\n    msd: [\"msd\", \"sgn\"],\n    msi: [\"msi\", \"ms\"],\n    msr: [\"msr\", \"sgn\"],\n    mui: [\"mui\", \"ms\"],\n    mzc: [\"mzc\", \"sgn\"],\n    mzg: [\"mzg\", \"sgn\"],\n    mzy: [\"mzy\", \"sgn\"],\n    nan: [\"nan\", \"zh\"],\n    nbs: [\"nbs\", \"sgn\"],\n    ncs: [\"ncs\", \"sgn\"],\n    nsi: [\"nsi\", \"sgn\"],\n    nsl: [\"nsl\", \"sgn\"],\n    nsp: [\"nsp\", \"sgn\"],\n    nsr: [\"nsr\", \"sgn\"],\n    nzs: [\"nzs\", \"sgn\"],\n    okl: [\"okl\", \"sgn\"],\n    orn: [\"orn\", \"ms\"],\n    ors: [\"ors\", \"ms\"],\n    pel: [\"pel\", \"ms\"],\n    pga: [\"pga\", \"ar\"],\n    pks: [\"pks\", \"sgn\"],\n    prl: [\"prl\", \"sgn\"],\n    prz: [\"prz\", \"sgn\"],\n    psc: [\"psc\", \"sgn\"],\n    psd: [\"psd\", \"sgn\"],\n    pse: [\"pse\", \"ms\"],\n    psg: [\"psg\", \"sgn\"],\n    psl: [\"psl\", \"sgn\"],\n    pso: [\"pso\", \"sgn\"],\n    psp: [\"psp\", \"sgn\"],\n    psr: [\"psr\", \"sgn\"],\n    pys: [\"pys\", \"sgn\"],\n    rms: [\"rms\", \"sgn\"],\n    rsi: [\"rsi\", \"sgn\"],\n    rsl: [\"rsl\", \"sgn\"],\n    sdl: [\"sdl\", \"sgn\"],\n    sfb: [\"sfb\", \"sgn\"],\n    sfs: [\"sfs\", \"sgn\"],\n    sgg: [\"sgg\", \"sgn\"],\n    sgx: [\"sgx\", \"sgn\"],\n    shu: [\"shu\", \"ar\"],\n    slf: [\"slf\", \"sgn\"],\n    sls: [\"sls\", \"sgn\"],\n    sqk: [\"sqk\", \"sgn\"],\n    sqs: [\"sqs\", \"sgn\"],\n    ssh: [\"ssh\", \"ar\"],\n    ssp: [\"ssp\", \"sgn\"],\n    ssr: [\"ssr\", \"sgn\"],\n    svk: [\"svk\", \"sgn\"],\n    swc: [\"swc\", \"sw\"],\n    swh: [\"swh\", \"sw\"],\n    swl: [\"swl\", \"sgn\"],\n    syy: [\"syy\", \"sgn\"],\n    tmw: [\"tmw\", \"ms\"],\n    tse: [\"tse\", \"sgn\"],\n    tsm: [\"tsm\", \"sgn\"],\n    tsq: [\"tsq\", \"sgn\"],\n    tss: [\"tss\", \"sgn\"],\n    tsy: [\"tsy\", \"sgn\"],\n    tza: [\"tza\", \"sgn\"],\n    ugn: [\"ugn\", \"sgn\"],\n    ugy: [\"ugy\", \"sgn\"],\n    ukl: [\"ukl\", \"sgn\"],\n    uks: [\"uks\", \"sgn\"],\n    urk: [\"urk\", \"ms\"],\n    uzn: [\"uzn\", \"uz\"],\n    uzs: [\"uzs\", \"uz\"],\n    vgt: [\"vgt\", \"sgn\"],\n    vkk: [\"vkk\", \"ms\"],\n    vkt: [\"vkt\", \"ms\"],\n    vsi: [\"vsi\", \"sgn\"],\n    vsl: [\"vsl\", \"sgn\"],\n    vsv: [\"vsv\", \"sgn\"],\n    wuu: [\"wuu\", \"zh\"],\n    xki: [\"xki\", \"sgn\"],\n    xml: [\"xml\", \"sgn\"],\n    xmm: [\"xmm\", \"ms\"],\n    xms: [\"xms\", \"sgn\"],\n    yds: [\"yds\", \"sgn\"],\n    ysl: [\"ysl\", \"sgn\"],\n    yue: [\"yue\", \"zh\"],\n    zib: [\"zib\", \"sgn\"],\n    zlm: [\"zlm\", \"ms\"],\n    zmi: [\"zmi\", \"ms\"],\n    zsl: [\"zsl\", \"sgn\"],\n    zsm: [\"zsm\", \"ms\"]\n  }\n};\n/**\n * Convert only a-z to uppercase as per section 6.1 of the spec\n */\n\nfunction toLatinUpperCase(str) {\n  var i = str.length;\n\n  while (i--) {\n    var ch = str.charAt(i);\n    if (ch >= \"a\" && ch <= \"z\") str = str.slice(0, i) + ch.toUpperCase() + str.slice(i + 1);\n  }\n\n  return str;\n}\n/**\n * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n * argument (which must be a String value)\n *\n * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n *   2.1, or successor,\n * - does not include duplicate variant subtags, and\n * - does not include duplicate singleton subtags.\n *\n * The abstract operation returns true if locale can be generated from the ABNF\n * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n * contain duplicate variant or singleton subtags (other than as a private use\n * subtag). It returns false otherwise. Terminal value characters in the grammar are\n * interpreted as the Unicode equivalents of the ASCII octet values given.\n */\n\n\nfunction\n/* 6.2.2 */\nIsStructurallyValidLanguageTag(locale) {\n  // represents a well-formed BCP 47 language tag as specified in RFC 5646\n  if (!expBCP47Syntax.test(locale)) return false; // does not include duplicate variant subtags, and\n\n  if (expVariantDupes.test(locale)) return false; // does not include duplicate singleton subtags.\n\n  if (expSingletonDupes.test(locale)) return false;\n  return true;\n}\n/**\n * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n * regularized form of the locale argument (which must be a String value that is\n * a structurally valid BCP 47 language tag as verified by the\n * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n * into canonical form, and to regularize the case of the subtags, but does not\n * take the steps to bring a language tag into “extlang form” and to reorder\n * variant subtags.\n\n * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n * may include canonicalization rules for the extension subtag sequences they\n * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n * Implementations are allowed, but not required, to apply these additional rules.\n */\n\n\nfunction\n/* 6.2.3 */\nCanonicalizeLanguageTag(locale) {\n  var match = void 0,\n      parts = void 0; // A language tag is in 'canonical form' when the tag is well-formed\n  // according to the rules in Sections 2.1 and 2.2\n  // Section 2.1 says all subtags use lowercase...\n\n  locale = locale.toLowerCase(); // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n  // appear at the start of the tag nor occur after singletons.  Such two-letter\n  // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n  // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n\n  parts = locale.split('-');\n\n  for (var i = 1, max = parts.length; i < max; i++) {\n    // Two-letter subtags are all uppercase\n    if (parts[i].length === 2) parts[i] = parts[i].toUpperCase(); // Four-letter subtags are titlecase\n    else if (parts[i].length === 4) parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1); // Is it a singleton?\n      else if (parts[i].length === 1 && parts[i] !== 'x') break;\n  }\n\n  locale = arrJoin.call(parts, '-'); // The steps laid out in RFC 5646 section 4.5 are as follows:\n  // 1.  Extension sequences are ordered into case-insensitive ASCII order\n  //     by singleton subtag.\n\n  if ((match = locale.match(expExtSequences)) && match.length > 1) {\n    // The built-in sort() sorts by ASCII order, so use that\n    match.sort(); // Replace all extensions with the joined, sorted array\n\n    locale = locale.replace(RegExp('(?:' + expExtSequences.source + ')+', 'i'), arrJoin.call(match, ''));\n  } // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n  //     Value', if there is one.\n\n\n  if (hop.call(redundantTags.tags, locale)) locale = redundantTags.tags[locale]; // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n  //     For extlangs, the original primary language subtag is also\n  //     replaced if there is a primary language subtag in the 'Preferred-\n  //     Value'.\n\n  parts = locale.split('-');\n\n  for (var _i = 1, _max = parts.length; _i < _max; _i++) {\n    if (hop.call(redundantTags.subtags, parts[_i])) parts[_i] = redundantTags.subtags[parts[_i]];else if (hop.call(redundantTags.extLang, parts[_i])) {\n      parts[_i] = redundantTags.extLang[parts[_i]][0]; // For extlang tags, the prefix needs to be removed if it is redundant\n\n      if (_i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n        parts = arrSlice.call(parts, _i++);\n        _max -= 1;\n      }\n    }\n  }\n\n  return arrJoin.call(parts, '-');\n}\n/**\n * The DefaultLocale abstract operation returns a String value representing the\n * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n * host environment’s current locale.\n */\n\n\nfunction\n/* 6.2.4 */\nDefaultLocale() {\n  return defaultLocale;\n} // Sect 6.3 Currency Codes\n// =======================\n\n\nvar expCurrencyCode = /^[A-Z]{3}$/;\n/**\n * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n * code. The following steps are taken:\n */\n\nfunction\n/* 6.3.1 */\nIsWellFormedCurrencyCode(currency) {\n  // 1. Let `c` be ToString(currency)\n  var c = String(currency); // 2. Let `normalized` be the result of mapping c to upper case as described\n  //    in 6.1.\n\n  var normalized = toLatinUpperCase(c); // 3. If the string length of normalized is not 3, return false.\n  // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n  //    (U+0041 to U+005A), return false.\n\n  if (expCurrencyCode.test(normalized) === false) return false; // 5. Return true\n\n  return true;\n}\n\nvar expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi; // See `extension` below\n\nfunction\n/* 9.2.1 */\nCanonicalizeLocaleList(locales) {\n  // The abstract operation CanonicalizeLocaleList takes the following steps:\n  // 1. If locales is undefined, then a. Return a new empty List\n  if (locales === undefined) return new List(); // 2. Let seen be a new empty List.\n\n  var seen = new List(); // 3. If locales is a String value, then\n  //    a. Let locales be a new array created as if by the expression new\n  //    Array(locales) where Array is the standard built-in constructor with\n  //    that name and locales is the value of locales.\n\n  locales = typeof locales === 'string' ? [locales] : locales; // 4. Let O be ToObject(locales).\n\n  var O = toObject(locales); // 5. Let lenValue be the result of calling the [[Get]] internal method of\n  //    O with the argument \"length\".\n  // 6. Let len be ToUint32(lenValue).\n\n  var len = toLength(O.length); // 7. Let k be 0.\n\n  var k = 0; // 8. Repeat, while k < len\n\n  while (k < len) {\n    // a. Let Pk be ToString(k).\n    var Pk = String(k); // b. Let kPresent be the result of calling the [[HasProperty]] internal\n    //    method of O with argument Pk.\n\n    var kPresent = Pk in O; // c. If kPresent is true, then\n\n    if (kPresent) {\n      // i. Let kValue be the result of calling the [[Get]] internal\n      //     method of O with argument Pk.\n      var kValue = O[Pk]; // ii. If the type of kValue is not String or Object, then throw a\n      //     TypeError exception.\n\n      if (kValue === null || typeof kValue !== 'string' && (typeof kValue === \"undefined\" ? \"undefined\" : babelHelpers$1[\"typeof\"](kValue)) !== 'object') throw new TypeError('String or Object type expected'); // iii. Let tag be ToString(kValue).\n\n      var tag = String(kValue); // iv. If the result of calling the abstract operation\n      //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n      //     the argument, is false, then throw a RangeError exception.\n\n      if (!IsStructurallyValidLanguageTag(tag)) throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\"); // v. Let tag be the result of calling the abstract operation\n      //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n      //    argument.\n\n      tag = CanonicalizeLanguageTag(tag); // vi. If tag is not an element of seen, then append tag as the last\n      //     element of seen.\n\n      if (arrIndexOf.call(seen, tag) === -1) arrPush.call(seen, tag);\n    } // d. Increase k by 1.\n\n\n    k++;\n  } // 9. Return seen.\n\n\n  return seen;\n}\n/**\n * The BestAvailableLocale abstract operation compares the provided argument\n * locale, which must be a String value with a structurally valid and\n * canonicalized BCP 47 language tag, against the locales in availableLocales and\n * returns either the longest non-empty prefix of locale that is an element of\n * availableLocales, or undefined if there is no such element. It uses the\n * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n */\n\n\nfunction\n/* 9.2.2 */\nBestAvailableLocale(availableLocales, locale) {\n  // 1. Let candidate be locale\n  var candidate = locale; // 2. Repeat\n\n  while (candidate) {\n    // a. If availableLocales contains an element equal to candidate, then return\n    // candidate.\n    if (arrIndexOf.call(availableLocales, candidate) > -1) return candidate; // b. Let pos be the character index of the last occurrence of \"-\"\n    // (U+002D) within candidate. If that character does not occur, return\n    // undefined.\n\n    var pos = candidate.lastIndexOf('-');\n    if (pos < 0) return; // c. If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate,\n    //    then decrease pos by 2.\n\n    if (pos >= 2 && candidate.charAt(pos - 2) === '-') pos -= 2; // d. Let candidate be the substring of candidate from position 0, inclusive,\n    //    to position pos, exclusive.\n\n    candidate = candidate.substring(0, pos);\n  }\n}\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The following steps are taken:\n */\n\n\nfunction\n/* 9.2.3 */\nLookupMatcher(availableLocales, requestedLocales) {\n  // 1. Let i be 0.\n  var i = 0; // 2. Let len be the number of elements in requestedLocales.\n\n  var len = requestedLocales.length; // 3. Let availableLocale be undefined.\n\n  var availableLocale = void 0;\n  var locale = void 0,\n      noExtensionsLocale = void 0; // 4. Repeat while i < len and availableLocale is undefined:\n\n  while (i < len && !availableLocale) {\n    // a. Let locale be the element of requestedLocales at 0-origined list\n    //    position i.\n    locale = requestedLocales[i]; // b. Let noExtensionsLocale be the String value that is locale with all\n    //    Unicode locale extension sequences removed.\n\n    noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''); // c. Let availableLocale be the result of calling the\n    //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n    //    arguments availableLocales and noExtensionsLocale.\n\n    availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale); // d. Increase i by 1.\n\n    i++;\n  } // 5. Let result be a new Record.\n\n\n  var result = new Record(); // 6. If availableLocale is not undefined, then\n\n  if (availableLocale !== undefined) {\n    // a. Set result.[[locale]] to availableLocale.\n    result['[[locale]]'] = availableLocale; // b. If locale and noExtensionsLocale are not the same String value, then\n\n    if (String(locale) !== String(noExtensionsLocale)) {\n      // i. Let extension be the String value consisting of the first\n      //    substring of locale that is a Unicode locale extension sequence.\n      var extension = locale.match(expUnicodeExSeq)[0]; // ii. Let extensionIndex be the character position of the initial\n      //     \"-\" of the first Unicode locale extension sequence within locale.\n\n      var extensionIndex = locale.indexOf('-u-'); // iii. Set result.[[extension]] to extension.\n\n      result['[[extension]]'] = extension; // iv. Set result.[[extensionIndex]] to extensionIndex.\n\n      result['[[extensionIndex]]'] = extensionIndex;\n    }\n  } // 7. Else\n  else // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n    //    operation (defined in 6.2.4).\n    result['[[locale]]'] = DefaultLocale(); // 8. Return result\n\n\n  return result;\n}\n/**\n * The BestFitMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The algorithm is implementation dependent, but should produce results\n * that a typical user of the requested locales would perceive as at least as\n * good as those produced by the LookupMatcher abstract operation. Options\n * specified through Unicode locale extension sequences must be ignored by the\n * algorithm. Information about such subsequences is returned separately.\n * The abstract operation returns a record with a [[locale]] field, whose value\n * is the language tag of the selected locale, which must be an element of\n * availableLocales. If the language tag of the request locale that led to the\n * selected locale contained a Unicode locale extension sequence, then the\n * returned record also contains an [[extension]] field whose value is the first\n * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n * is the index of the first Unicode locale extension sequence within the request\n * locale language tag.\n */\n\n\nfunction\n/* 9.2.4 */\nBestFitMatcher(availableLocales, requestedLocales) {\n  return LookupMatcher(availableLocales, requestedLocales);\n}\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the\n * best available language to meet the request. availableLocales and\n * requestedLocales must be provided as List values, options as a Record.\n */\n\n\nfunction\n/* 9.2.5 */\nResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n  if (availableLocales.length === 0) {\n    throw new ReferenceError('No locale data has been provided for this object yet.');\n  } // The following steps are taken:\n  // 1. Let matcher be the value of options.[[localeMatcher]].\n\n\n  var matcher = options['[[localeMatcher]]'];\n  var r = void 0; // 2. If matcher is \"lookup\", then\n\n  if (matcher === 'lookup') // a. Let r be the result of calling the LookupMatcher abstract operation\n    //    (defined in 9.2.3) with arguments availableLocales and\n    //    requestedLocales.\n    r = LookupMatcher(availableLocales, requestedLocales); // 3. Else\n  else // a. Let r be the result of calling the BestFitMatcher abstract\n    //    operation (defined in 9.2.4) with arguments availableLocales and\n    //    requestedLocales.\n    r = BestFitMatcher(availableLocales, requestedLocales); // 4. Let foundLocale be the value of r.[[locale]].\n\n  var foundLocale = r['[[locale]]'];\n  var extensionSubtags = void 0,\n      extensionSubtagsLength = void 0; // 5. If r has an [[extension]] field, then\n\n  if (hop.call(r, '[[extension]]')) {\n    // a. Let extension be the value of r.[[extension]].\n    var extension = r['[[extension]]']; // b. Let split be the standard built-in function object defined in ES5,\n    //    15.5.4.14.\n\n    var split = String.prototype.split; // c. Let extensionSubtags be the result of calling the [[Call]] internal\n    //    method of split with extension as the this value and an argument\n    //    list containing the single item \"-\".\n\n    extensionSubtags = split.call(extension, '-'); // d. Let extensionSubtagsLength be the result of calling the [[Get]]\n    //    internal method of extensionSubtags with argument \"length\".\n\n    extensionSubtagsLength = extensionSubtags.length;\n  } // 6. Let result be a new Record.\n\n\n  var result = new Record(); // 7. Set result.[[dataLocale]] to foundLocale.\n\n  result['[[dataLocale]]'] = foundLocale; // 8. Let supportedExtension be \"-u\".\n\n  var supportedExtension = '-u'; // 9. Let i be 0.\n\n  var i = 0; // 10. Let len be the result of calling the [[Get]] internal method of\n  //     relevantExtensionKeys with argument \"length\".\n\n  var len = relevantExtensionKeys.length; // 11 Repeat while i < len:\n\n  while (i < len) {\n    // a. Let key be the result of calling the [[Get]] internal method of\n    //    relevantExtensionKeys with argument ToString(i).\n    var key = relevantExtensionKeys[i]; // b. Let foundLocaleData be the result of calling the [[Get]] internal\n    //    method of localeData with the argument foundLocale.\n\n    var foundLocaleData = localeData[foundLocale]; // c. Let keyLocaleData be the result of calling the [[Get]] internal\n    //    method of foundLocaleData with the argument key.\n\n    var keyLocaleData = foundLocaleData[key]; // d. Let value be the result of calling the [[Get]] internal method of\n    //    keyLocaleData with argument \"0\".\n\n    var value = keyLocaleData['0']; // e. Let supportedExtensionAddition be \"\".\n\n    var supportedExtensionAddition = ''; // f. Let indexOf be the standard built-in function object defined in\n    //    ES5, 15.4.4.14.\n\n    var indexOf = arrIndexOf; // g. If extensionSubtags is not undefined, then\n\n    if (extensionSubtags !== undefined) {\n      // i. Let keyPos be the result of calling the [[Call]] internal\n      //    method of indexOf with extensionSubtags as the this value and\n      // an argument list containing the single item key.\n      var keyPos = indexOf.call(extensionSubtags, key); // ii. If keyPos ≠ -1, then\n\n      if (keyPos !== -1) {\n        // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n        //    result of calling the [[Get]] internal method of\n        //    extensionSubtags with argument ToString(keyPos +1) is greater\n        //    than 2, then\n        if (keyPos + 1 < extensionSubtagsLength && extensionSubtags[keyPos + 1].length > 2) {\n          // a. Let requestedValue be the result of calling the [[Get]]\n          //    internal method of extensionSubtags with argument\n          //    ToString(keyPos + 1).\n          var requestedValue = extensionSubtags[keyPos + 1]; // b. Let valuePos be the result of calling the [[Call]]\n          //    internal method of indexOf with keyLocaleData as the\n          //    this value and an argument list containing the single\n          //    item requestedValue.\n\n          var valuePos = indexOf.call(keyLocaleData, requestedValue); // c. If valuePos ≠ -1, then\n\n          if (valuePos !== -1) {\n            // i. Let value be requestedValue.\n            value = requestedValue, // ii. Let supportedExtensionAddition be the\n            //     concatenation of \"-\", key, \"-\", and value.\n            supportedExtensionAddition = '-' + key + '-' + value;\n          }\n        } // 2. Else\n        else {\n            // a. Let valuePos be the result of calling the [[Call]]\n            // internal method of indexOf with keyLocaleData as the this\n            // value and an argument list containing the single item\n            // \"true\".\n            var _valuePos = indexOf(keyLocaleData, 'true'); // b. If valuePos ≠ -1, then\n\n\n            if (_valuePos !== -1) // i. Let value be \"true\".\n              value = 'true';\n          }\n      }\n    } // h. If options has a field [[<key>]], then\n\n\n    if (hop.call(options, '[[' + key + ']]')) {\n      // i. Let optionsValue be the value of options.[[<key>]].\n      var optionsValue = options['[[' + key + ']]']; // ii. If the result of calling the [[Call]] internal method of indexOf\n      //     with keyLocaleData as the this value and an argument list\n      //     containing the single item optionsValue is not -1, then\n\n      if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n        // 1. If optionsValue is not equal to value, then\n        if (optionsValue !== value) {\n          // a. Let value be optionsValue.\n          value = optionsValue; // b. Let supportedExtensionAddition be \"\".\n\n          supportedExtensionAddition = '';\n        }\n      }\n    } // i. Set result.[[<key>]] to value.\n\n\n    result['[[' + key + ']]'] = value; // j. Append supportedExtensionAddition to supportedExtension.\n\n    supportedExtension += supportedExtensionAddition; // k. Increase i by 1.\n\n    i++;\n  } // 12. If the length of supportedExtension is greater than 2, then\n\n\n  if (supportedExtension.length > 2) {\n    // a.\n    var privateIndex = foundLocale.indexOf(\"-x-\"); // b.\n\n    if (privateIndex === -1) {\n      // i.\n      foundLocale = foundLocale + supportedExtension;\n    } // c.\n    else {\n        // i.\n        var preExtension = foundLocale.substring(0, privateIndex); // ii.\n\n        var postExtension = foundLocale.substring(privateIndex); // iii.\n\n        foundLocale = preExtension + supportedExtension + postExtension;\n      } // d. asserting - skipping\n    // e.\n\n\n    foundLocale = CanonicalizeLanguageTag(foundLocale);\n  } // 13. Set result.[[locale]] to foundLocale.\n\n\n  result['[[locale]]'] = foundLocale; // 14. Return result.\n\n  return result;\n}\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n * The following steps are taken:\n */\n\n\nfunction\n/* 9.2.6 */\nLookupSupportedLocales(availableLocales, requestedLocales) {\n  // 1. Let len be the number of elements in requestedLocales.\n  var len = requestedLocales.length; // 2. Let subset be a new empty List.\n\n  var subset = new List(); // 3. Let k be 0.\n\n  var k = 0; // 4. Repeat while k < len\n\n  while (k < len) {\n    // a. Let locale be the element of requestedLocales at 0-origined list\n    //    position k.\n    var locale = requestedLocales[k]; // b. Let noExtensionsLocale be the String value that is locale with all\n    //    Unicode locale extension sequences removed.\n\n    var noExtensionsLocale = String(locale).replace(expUnicodeExSeq, ''); // c. Let availableLocale be the result of calling the\n    //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n    //    arguments availableLocales and noExtensionsLocale.\n\n    var availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale); // d. If availableLocale is not undefined, then append locale to the end of\n    //    subset.\n\n    if (availableLocale !== undefined) arrPush.call(subset, locale); // e. Increment k by 1.\n\n    k++;\n  } // 5. Let subsetArray be a new Array object whose elements are the same\n  //    values in the same order as the elements of subset.\n\n\n  var subsetArray = arrSlice.call(subset); // 6. Return subsetArray.\n\n  return subsetArray;\n}\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the Best Fit Matcher\n * algorithm. Locales appear in the same order in the returned list as in\n * requestedLocales. The steps taken are implementation dependent.\n */\n\n\nfunction\n/*9.2.7 */\nBestFitSupportedLocales(availableLocales, requestedLocales) {\n  // ###TODO: implement this function as described by the specification###\n  return LookupSupportedLocales(availableLocales, requestedLocales);\n}\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP\n * 47 language priority list requestedLocales for which availableLocales has a\n * matching locale. Two algorithms are available to match the locales: the Lookup\n * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as\n * in requestedLocales. The following steps are taken:\n */\n\n\nfunction\n/*9.2.8 */\nSupportedLocales(availableLocales, requestedLocales, options) {\n  var matcher = void 0,\n      subset = void 0; // 1. If options is not undefined, then\n\n  if (options !== undefined) {\n    // a. Let options be ToObject(options).\n    options = new Record(toObject(options)); // b. Let matcher be the result of calling the [[Get]] internal method of\n    //    options with argument \"localeMatcher\".\n\n    matcher = options.localeMatcher; // c. If matcher is not undefined, then\n\n    if (matcher !== undefined) {\n      // i. Let matcher be ToString(matcher).\n      matcher = String(matcher); // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n      //     exception.\n\n      if (matcher !== 'lookup' && matcher !== 'best fit') throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n    }\n  } // 2. If matcher is undefined or \"best fit\", then\n\n\n  if (matcher === undefined || matcher === 'best fit') // a. Let subset be the result of calling the BestFitSupportedLocales\n    //    abstract operation (defined in 9.2.7) with arguments\n    //    availableLocales and requestedLocales.\n    subset = BestFitSupportedLocales(availableLocales, requestedLocales); // 3. Else\n  else // a. Let subset be the result of calling the LookupSupportedLocales\n    //    abstract operation (defined in 9.2.6) with arguments\n    //    availableLocales and requestedLocales.\n    subset = LookupSupportedLocales(availableLocales, requestedLocales); // 4. For each named own property name P of subset,\n\n  for (var P in subset) {\n    if (!hop.call(subset, P)) continue; // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n    //    method of subset with P.\n    // b. Set desc.[[Writable]] to false.\n    // c. Set desc.[[Configurable]] to false.\n    // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n    //    and true as arguments.\n\n    defineProperty(subset, P, {\n      writable: false,\n      configurable: false,\n      value: subset[P]\n    });\n  } // \"Freeze\" the array so no new elements can be added\n\n\n  defineProperty(subset, 'length', {\n    writable: false\n  }); // 5. Return subset\n\n  return subset;\n}\n/**\n * The GetOption abstract operation extracts the value of the property named\n * property from the provided options object, converts it to the required type,\n * checks whether it is one of a List of allowed values, and fills in a fallback\n * value if necessary.\n */\n\n\nfunction\n/*9.2.9 */\nGetOption(options, property, type, values, fallback) {\n  // 1. Let value be the result of calling the [[Get]] internal method of\n  //    options with argument property.\n  var value = options[property]; // 2. If value is not undefined, then\n\n  if (value !== undefined) {\n    // a. Assert: type is \"boolean\" or \"string\".\n    // b. If type is \"boolean\", then let value be ToBoolean(value).\n    // c. If type is \"string\", then let value be ToString(value).\n    value = type === 'boolean' ? Boolean(value) : type === 'string' ? String(value) : value; // d. If values is not undefined, then\n\n    if (values !== undefined) {\n      // i. If values does not contain an element equal to value, then throw a\n      //    RangeError exception.\n      if (arrIndexOf.call(values, value) === -1) throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property + '`');\n    } // e. Return value.\n\n\n    return value;\n  } // Else return fallback.\n\n\n  return fallback;\n}\n/**\n * The GetNumberOption abstract operation extracts a property value from the\n * provided options object, converts it to a Number value, checks whether it is\n * in the allowed range, and fills in a fallback value if necessary.\n */\n\n\nfunction\n/* 9.2.10 */\nGetNumberOption(options, property, minimum, maximum, fallback) {\n  // 1. Let value be the result of calling the [[Get]] internal method of\n  //    options with argument property.\n  var value = options[property]; // 2. If value is not undefined, then\n\n  if (value !== undefined) {\n    // a. Let value be ToNumber(value).\n    value = Number(value); // b. If value is NaN or less than minimum or greater than maximum, throw a\n    //    RangeError exception.\n\n    if (isNaN(value) || value < minimum || value > maximum) throw new RangeError('Value is not a number or outside accepted range'); // c. Return floor(value).\n\n    return Math.floor(value);\n  } // 3. Else return fallback.\n\n\n  return fallback;\n} // 8 The Intl Object\n\n\nvar Intl = {}; // 8.2 Function Properties of the Intl Object\n// 8.2.1\n// @spec[tc39/ecma402/master/spec/intl.html]\n// @clause[sec-intl.getcanonicallocales]\n\nfunction getCanonicalLocales(locales) {\n  // 1. Let ll be ? CanonicalizeLocaleList(locales).\n  var ll = CanonicalizeLocaleList(locales); // 2. Return CreateArrayFromList(ll).\n\n  {\n    var result = [];\n    var len = ll.length;\n    var k = 0;\n\n    while (k < len) {\n      result[k] = ll[k];\n      k++;\n    }\n\n    return result;\n  }\n}\n\nObject.defineProperty(Intl, 'getCanonicalLocales', {\n  enumerable: false,\n  configurable: true,\n  writable: true,\n  value: getCanonicalLocales\n}); // Currency minor units output from get-4217 grunt task, formatted\n\nvar currencyMinorUnits = {\n  BHD: 3,\n  BYR: 0,\n  XOF: 0,\n  BIF: 0,\n  XAF: 0,\n  CLF: 4,\n  CLP: 0,\n  KMF: 0,\n  DJF: 0,\n  XPF: 0,\n  GNF: 0,\n  ISK: 0,\n  IQD: 3,\n  JPY: 0,\n  JOD: 3,\n  KRW: 0,\n  KWD: 3,\n  LYD: 3,\n  OMR: 3,\n  PYG: 0,\n  RWF: 0,\n  TND: 3,\n  UGX: 0,\n  UYI: 0,\n  VUV: 0,\n  VND: 0\n}; // Define the NumberFormat constructor internally so it cannot be tainted\n\nfunction NumberFormatConstructor() {\n  var locales = arguments[0];\n  var options = arguments[1];\n\n  if (!this || this === Intl) {\n    return new Intl.NumberFormat(locales, options);\n  }\n\n  return InitializeNumberFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'NumberFormat', {\n  configurable: true,\n  writable: true,\n  value: NumberFormatConstructor\n}); // Must explicitly set prototypes as unwritable\n\ndefineProperty(Intl.NumberFormat, 'prototype', {\n  writable: false\n});\n/**\n * The abstract operation InitializeNumberFormat accepts the arguments\n * numberFormat (which must be an object), locales, and options. It initializes\n * numberFormat as a NumberFormat object.\n */\n\nfunction\n/*11.1.1.1 */\nInitializeNumberFormat(numberFormat, locales, options) {\n  // This will be a internal properties object if we're not already initialized\n  var internal = getInternalProperties(numberFormat); // Create an object whose props can be used to restore the values of RegExp props\n\n  var regexpRestore = createRegExpRestore(); // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n  // value true, throw a TypeError exception.\n\n  if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object'); // Need this to access the `internal` object\n\n  defineProperty(numberFormat, '__getInternalProperties', {\n    value: function value() {\n      // NOTE: Non-standard, for internal use only\n      if (arguments[0] === secret) return internal;\n    }\n  }); // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n\n  internal['[[initializedIntlObject]]'] = true; // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n  //    abstract operation (defined in 9.2.1) with argument locales.\n\n  var requestedLocales = CanonicalizeLocaleList(locales); // 4. If options is undefined, then\n\n  if (options === undefined) // a. Let options be the result of creating a new object as if by the\n    // expression new Object() where Object is the standard built-in constructor\n    // with that name.\n    options = {}; // 5. Else\n  else // a. Let options be ToObject(options).\n    options = toObject(options); // 6. Let opt be a new Record.\n\n  var opt = new Record(),\n      // 7. Let matcher be the result of calling the GetOption abstract operation\n  //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n  //    a List containing the two String values \"lookup\" and \"best fit\", and\n  //    \"best fit\".\n  matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit'); // 8. Set opt.[[localeMatcher]] to matcher.\n\n  opt['[[localeMatcher]]'] = matcher; // 9. Let NumberFormat be the standard built-in object that is the initial value\n  //    of Intl.NumberFormat.\n  // 10. Let localeData be the value of the [[localeData]] internal property of\n  //     NumberFormat.\n\n  var localeData = internals.NumberFormat['[[localeData]]']; // 11. Let r be the result of calling the ResolveLocale abstract operation\n  //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n  //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n  //     internal property of NumberFormat, and localeData.\n\n  var r = ResolveLocale(internals.NumberFormat['[[availableLocales]]'], requestedLocales, opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData); // 12. Set the [[locale]] internal property of numberFormat to the value of\n  //     r.[[locale]].\n\n  internal['[[locale]]'] = r['[[locale]]']; // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n  //     of r.[[nu]].\n\n  internal['[[numberingSystem]]'] = r['[[nu]]']; // The specification doesn't tell us to do this, but it's helpful later on\n\n  internal['[[dataLocale]]'] = r['[[dataLocale]]']; // 14. Let dataLocale be the value of r.[[dataLocale]].\n\n  var dataLocale = r['[[dataLocale]]']; // 15. Let s be the result of calling the GetOption abstract operation with the\n  //     arguments options, \"style\", \"string\", a List containing the three String\n  //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n\n  var s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal'); // 16. Set the [[style]] internal property of numberFormat to s.\n\n  internal['[[style]]'] = s; // 17. Let c be the result of calling the GetOption abstract operation with the\n  //     arguments options, \"currency\", \"string\", undefined, and undefined.\n\n  var c = GetOption(options, 'currency', 'string'); // 18. If c is not undefined and the result of calling the\n  //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n  //     argument c is false, then throw a RangeError exception.\n\n  if (c !== undefined && !IsWellFormedCurrencyCode(c)) throw new RangeError(\"'\" + c + \"' is not a valid currency code\"); // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n\n  if (s === 'currency' && c === undefined) throw new TypeError('Currency code is required when style is currency');\n  var cDigits = void 0; // 20. If s is \"currency\", then\n\n  if (s === 'currency') {\n    // a. Let c be the result of converting c to upper case as specified in 6.1.\n    c = c.toUpperCase(); // b. Set the [[currency]] internal property of numberFormat to c.\n\n    internal['[[currency]]'] = c; // c. Let cDigits be the result of calling the CurrencyDigits abstract\n    //    operation (defined below) with argument c.\n\n    cDigits = CurrencyDigits(c);\n  } // 21. Let cd be the result of calling the GetOption abstract operation with the\n  //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n  //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n\n\n  var cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol'); // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n  //     numberFormat to cd.\n\n  if (s === 'currency') internal['[[currencyDisplay]]'] = cd; // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n  //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n  //     and 1.\n\n  var mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1); // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n\n  internal['[[minimumIntegerDigits]]'] = mnid; // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n  //     be 0.\n\n  var mnfdDefault = s === 'currency' ? cDigits : 0; // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n  //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n\n  var mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault); // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n\n  internal['[[minimumFractionDigits]]'] = mnfd; // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n  //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n  //     be max(mnfd, 3).\n\n  var mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits) : s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3); // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n  //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n\n  var mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault); // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n\n  internal['[[maximumFractionDigits]]'] = mxfd; // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n  //     with argument \"minimumSignificantDigits\".\n\n  var mnsd = options.minimumSignificantDigits; // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n  //     with argument \"maximumSignificantDigits\".\n\n  var mxsd = options.maximumSignificantDigits; // 33. If mnsd is not undefined or mxsd is not undefined, then:\n\n  if (mnsd !== undefined || mxsd !== undefined) {\n    // a. Let mnsd be the result of calling the GetNumberOption abstract\n    //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n    //    and 1.\n    mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1); // b. Let mxsd be the result of calling the GetNumberOption abstract\n    //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n    //     21, and 21.\n\n    mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21); // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n    //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n    //    numberFormat to mxsd.\n\n    internal['[[minimumSignificantDigits]]'] = mnsd;\n    internal['[[maximumSignificantDigits]]'] = mxsd;\n  } // 34. Let g be the result of calling the GetOption abstract operation with the\n  //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n\n\n  var g = GetOption(options, 'useGrouping', 'boolean', undefined, true); // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n\n  internal['[[useGrouping]]'] = g; // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n  //     localeData with argument dataLocale.\n\n  var dataLocaleData = localeData[dataLocale]; // 37. Let patterns be the result of calling the [[Get]] internal method of\n  //     dataLocaleData with argument \"patterns\".\n\n  var patterns = dataLocaleData.patterns; // 38. Assert: patterns is an object (see 11.2.3)\n  // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n  //     patterns with argument s.\n\n  var stylePatterns = patterns[s]; // 40. Set the [[positivePattern]] internal property of numberFormat to the\n  //     result of calling the [[Get]] internal method of stylePatterns with the\n  //     argument \"positivePattern\".\n\n  internal['[[positivePattern]]'] = stylePatterns.positivePattern; // 41. Set the [[negativePattern]] internal property of numberFormat to the\n  //     result of calling the [[Get]] internal method of stylePatterns with the\n  //     argument \"negativePattern\".\n\n  internal['[[negativePattern]]'] = stylePatterns.negativePattern; // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n\n  internal['[[boundFormat]]'] = undefined; // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n  //     true.\n\n  internal['[[initializedNumberFormat]]'] = true; // In ES3, we need to pre-bind the format() function\n\n  if (es3) numberFormat.format = GetFormatNumber.call(numberFormat); // Restore the RegExp properties\n\n  regexpRestore(); // Return the newly initialised object\n\n  return numberFormat;\n}\n\nfunction CurrencyDigits(currency) {\n  // When the CurrencyDigits abstract operation is called with an argument currency\n  // (which must be an upper case String value), the following steps are taken:\n  // 1. If the ISO 4217 currency and funds code list contains currency as an\n  // alphabetic code, then return the minor unit value corresponding to the\n  // currency from the list; else return 2.\n  return currencyMinorUnits[currency] !== undefined ? currencyMinorUnits[currency] : 2;\n}\n/* 11.2.3 */\n\n\ninternals.NumberFormat = {\n  '[[availableLocales]]': [],\n  '[[relevantExtensionKeys]]': ['nu'],\n  '[[localeData]]': {}\n};\n/**\n * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n * following steps are taken:\n */\n\n/* 11.2.2 */\n\ndefineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n  configurable: true,\n  writable: true,\n  value: fnBind.call(function (locales) {\n    // Bound functions only have the `this` value altered if being used as a constructor,\n    // this lets us imitate a native function that has no constructor\n    if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor'); // Create an object whose props can be used to restore the values of RegExp props\n\n    var regexpRestore = createRegExpRestore(),\n        // 1. If options is not provided, then let options be undefined.\n    options = arguments[1],\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n    //    property of the standard built-in object that is the initial value of\n    //    Intl.NumberFormat.\n    availableLocales = this['[[availableLocales]]'],\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    requestedLocales = CanonicalizeLocaleList(locales); // Restore the RegExp properties\n\n    regexpRestore(); // 4. Return the result of calling the SupportedLocales abstract operation\n    //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n    //    and options.\n\n    return SupportedLocales(availableLocales, requestedLocales, options);\n  }, internals.NumberFormat)\n});\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * NumberFormat object.\n */\n\n/* 11.3.2 */\n\ndefineProperty(Intl.NumberFormat.prototype, 'format', {\n  configurable: true,\n  get: GetFormatNumber\n});\n\nfunction GetFormatNumber() {\n  var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this); // Satisfy test 11.3_b\n\n  if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.'); // The value of the [[Get]] attribute is a function that takes the following\n  // steps:\n  // 1. If the [[boundFormat]] internal property of this NumberFormat object\n  //    is undefined, then:\n\n  if (internal['[[boundFormat]]'] === undefined) {\n    // a. Let F be a Function object, with internal properties set as\n    //    specified for built-in functions in ES5, 15, or successor, and the\n    //    length property set to 1, that takes the argument value and\n    //    performs the following steps:\n    var F = function F(value) {\n      // i. If value is not provided, then let value be undefined.\n      // ii. Let x be ToNumber(value).\n      // iii. Return the result of calling the FormatNumber abstract\n      //      operation (defined below) with arguments this and x.\n      return FormatNumber(this,\n      /* x = */\n      Number(value));\n    }; // b. Let bind be the standard built-in function object defined in ES5,\n    //    15.3.4.5.\n    // c. Let bf be the result of calling the [[Call]] internal method of\n    //    bind with F as the this value and an argument list containing\n    //    the single item this.\n\n\n    var bf = fnBind.call(F, this); // d. Set the [[boundFormat]] internal property of this NumberFormat\n    //    object to bf.\n\n    internal['[[boundFormat]]'] = bf;\n  } // Return the value of the [[boundFormat]] internal property of this\n  // NumberFormat object.\n\n\n  return internal['[[boundFormat]]'];\n}\n\nfunction formatToParts() {\n  var value = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n  var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n  if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.NumberFormat object.');\n  var x = Number(value);\n  return FormatNumberToParts(this, x);\n}\n\nObject.defineProperty(Intl.NumberFormat.prototype, 'formatToParts', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: formatToParts\n});\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-formatnumbertoparts]\n */\n\nfunction FormatNumberToParts(numberFormat, x) {\n  // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n  var parts = PartitionNumberPattern(numberFormat, x); // 2. Let result be ArrayCreate(0).\n\n  var result = []; // 3. Let n be 0.\n\n  var n = 0; // 4. For each part in parts, do:\n\n  for (var i = 0; parts.length > i; i++) {\n    var part = parts[i]; // a. Let O be ObjectCreate(%ObjectPrototype%).\n\n    var O = {}; // a. Perform ? CreateDataPropertyOrThrow(O, \"type\", part.[[type]]).\n\n    O.type = part['[[type]]']; // a. Perform ? CreateDataPropertyOrThrow(O, \"value\", part.[[value]]).\n\n    O.value = part['[[value]]']; // a. Perform ? CreateDataPropertyOrThrow(result, ? ToString(n), O).\n\n    result[n] = O; // a. Increment n by 1.\n\n    n += 1;\n  } // 5. Return result.\n\n\n  return result;\n}\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-partitionnumberpattern]\n */\n\n\nfunction PartitionNumberPattern(numberFormat, x) {\n  var internal = getInternalProperties(numberFormat),\n      locale = internal['[[dataLocale]]'],\n      nums = internal['[[numberingSystem]]'],\n      data = internals.NumberFormat['[[localeData]]'][locale],\n      ild = data.symbols[nums] || data.symbols.latn,\n      pattern = void 0; // 1. If x is not NaN and x < 0, then:\n\n  if (!isNaN(x) && x < 0) {\n    // a. Let x be -x.\n    x = -x; // a. Let pattern be the value of numberFormat.[[negativePattern]].\n\n    pattern = internal['[[negativePattern]]'];\n  } // 2. Else,\n  else {\n      // a. Let pattern be the value of numberFormat.[[positivePattern]].\n      pattern = internal['[[positivePattern]]'];\n    } // 3. Let result be a new empty List.\n\n\n  var result = new List(); // 4. Let beginIndex be Call(%StringProto_indexOf%, pattern, \"{\", 0).\n\n  var beginIndex = pattern.indexOf('{', 0); // 5. Let endIndex be 0.\n\n  var endIndex = 0; // 6. Let nextIndex be 0.\n\n  var nextIndex = 0; // 7. Let length be the number of code units in pattern.\n\n  var length = pattern.length; // 8. Repeat while beginIndex is an integer index into pattern:\n\n  while (beginIndex > -1 && beginIndex < length) {\n    // a. Set endIndex to Call(%StringProto_indexOf%, pattern, \"}\", beginIndex)\n    endIndex = pattern.indexOf('}', beginIndex); // a. If endIndex = -1, throw new Error exception.\n\n    if (endIndex === -1) throw new Error(); // a. If beginIndex is greater than nextIndex, then:\n\n    if (beginIndex > nextIndex) {\n      // i. Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n      var literal = pattern.substring(nextIndex, beginIndex); // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n\n      arrPush.call(result, {\n        '[[type]]': 'literal',\n        '[[value]]': literal\n      });\n    } // a. Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n\n\n    var p = pattern.substring(beginIndex + 1, endIndex); // a. If p is equal \"number\", then:\n\n    if (p === \"number\") {\n      // i. If x is NaN,\n      if (isNaN(x)) {\n        // 1. Let n be an ILD String value indicating the NaN value.\n        var n = ild.nan; // 2. Add new part record { [[type]]: \"nan\", [[value]]: n } as a new element of the list result.\n\n        arrPush.call(result, {\n          '[[type]]': 'nan',\n          '[[value]]': n\n        });\n      } // ii. Else if isFinite(x) is false,\n      else if (!isFinite(x)) {\n          // 1. Let n be an ILD String value indicating infinity.\n          var _n = ild.infinity; // 2. Add new part record { [[type]]: \"infinity\", [[value]]: n } as a new element of the list result.\n\n          arrPush.call(result, {\n            '[[type]]': 'infinity',\n            '[[value]]': _n\n          });\n        } // iii. Else,\n        else {\n            // 1. If the value of numberFormat.[[style]] is \"percent\" and isFinite(x), let x be 100 × x.\n            if (internal['[[style]]'] === 'percent' && isFinite(x)) x *= 100;\n\n            var _n2 = void 0; // 2. If the numberFormat.[[minimumSignificantDigits]] and numberFormat.[[maximumSignificantDigits]] are present, then\n\n\n            if (hop.call(internal, '[[minimumSignificantDigits]]') && hop.call(internal, '[[maximumSignificantDigits]]')) {\n              // a. Let n be ToRawPrecision(x, numberFormat.[[minimumSignificantDigits]], numberFormat.[[maximumSignificantDigits]]).\n              _n2 = ToRawPrecision(x, internal['[[minimumSignificantDigits]]'], internal['[[maximumSignificantDigits]]']);\n            } // 3. Else,\n            else {\n                // a. Let n be ToRawFixed(x, numberFormat.[[minimumIntegerDigits]], numberFormat.[[minimumFractionDigits]], numberFormat.[[maximumFractionDigits]]).\n                _n2 = ToRawFixed(x, internal['[[minimumIntegerDigits]]'], internal['[[minimumFractionDigits]]'], internal['[[maximumFractionDigits]]']);\n              } // 4. If the value of the numberFormat.[[numberingSystem]] matches one of the values in the \"Numbering System\" column of Table 2 below, then\n\n\n            if (numSys[nums]) {\n              (function () {\n                // a. Let digits be an array whose 10 String valued elements are the UTF-16 string representations of the 10 digits specified in the \"Digits\" column of the matching row in Table 2.\n                var digits = numSys[nums]; // a. Replace each digit in n with the value of digits[digit].\n\n                _n2 = String(_n2).replace(/\\d/g, function (digit) {\n                  return digits[digit];\n                });\n              })();\n            } // 5. Else use an implementation dependent algorithm to map n to the appropriate representation of n in the given numbering system.\n            else _n2 = String(_n2); // ###TODO###\n\n\n            var integer = void 0;\n            var fraction = void 0; // 6. Let decimalSepIndex be Call(%StringProto_indexOf%, n, \".\", 0).\n\n            var decimalSepIndex = _n2.indexOf('.', 0); // 7. If decimalSepIndex > 0, then:\n\n\n            if (decimalSepIndex > 0) {\n              // a. Let integer be the substring of n from position 0, inclusive, to position decimalSepIndex, exclusive.\n              integer = _n2.substring(0, decimalSepIndex); // a. Let fraction be the substring of n from position decimalSepIndex, exclusive, to the end of n.\n\n              fraction = _n2.substring(decimalSepIndex + 1, decimalSepIndex.length);\n            } // 8. Else:\n            else {\n                // a. Let integer be n.\n                integer = _n2; // a. Let fraction be undefined.\n\n                fraction = undefined;\n              } // 9. If the value of the numberFormat.[[useGrouping]] is true,\n\n\n            if (internal['[[useGrouping]]'] === true) {\n              // a. Let groupSepSymbol be the ILND String representing the grouping separator.\n              var groupSepSymbol = ild.group; // a. Let groups be a List whose elements are, in left to right order, the substrings defined by ILND set of locations within the integer.\n\n              var groups = []; // ----> implementation:\n              // Primary group represents the group closest to the decimal\n\n              var pgSize = data.patterns.primaryGroupSize || 3; // Secondary group is every other group\n\n              var sgSize = data.patterns.secondaryGroupSize || pgSize; // Group only if necessary\n\n              if (integer.length > pgSize) {\n                // Index of the primary grouping separator\n                var end = integer.length - pgSize; // Starting index for our loop\n\n                var idx = end % sgSize;\n                var start = integer.slice(0, idx);\n                if (start.length) arrPush.call(groups, start); // Loop to separate into secondary grouping digits\n\n                while (idx < end) {\n                  arrPush.call(groups, integer.slice(idx, idx + sgSize));\n                  idx += sgSize;\n                } // Add the primary grouping digits\n\n\n                arrPush.call(groups, integer.slice(end));\n              } else {\n                arrPush.call(groups, integer);\n              } // a. Assert: The number of elements in groups List is greater than 0.\n\n\n              if (groups.length === 0) throw new Error(); // a. Repeat, while groups List is not empty:\n\n              while (groups.length) {\n                // i. Remove the first element from groups and let integerGroup be the value of that element.\n                var integerGroup = arrShift.call(groups); // ii. Add new part record { [[type]]: \"integer\", [[value]]: integerGroup } as a new element of the list result.\n\n                arrPush.call(result, {\n                  '[[type]]': 'integer',\n                  '[[value]]': integerGroup\n                }); // iii. If groups List is not empty, then:\n\n                if (groups.length) {\n                  // 1. Add new part record { [[type]]: \"group\", [[value]]: groupSepSymbol } as a new element of the list result.\n                  arrPush.call(result, {\n                    '[[type]]': 'group',\n                    '[[value]]': groupSepSymbol\n                  });\n                }\n              }\n            } // 10. Else,\n            else {\n                // a. Add new part record { [[type]]: \"integer\", [[value]]: integer } as a new element of the list result.\n                arrPush.call(result, {\n                  '[[type]]': 'integer',\n                  '[[value]]': integer\n                });\n              } // 11. If fraction is not undefined, then:\n\n\n            if (fraction !== undefined) {\n              // a. Let decimalSepSymbol be the ILND String representing the decimal separator.\n              var decimalSepSymbol = ild.decimal; // a. Add new part record { [[type]]: \"decimal\", [[value]]: decimalSepSymbol } as a new element of the list result.\n\n              arrPush.call(result, {\n                '[[type]]': 'decimal',\n                '[[value]]': decimalSepSymbol\n              }); // a. Add new part record { [[type]]: \"fraction\", [[value]]: fraction } as a new element of the list result.\n\n              arrPush.call(result, {\n                '[[type]]': 'fraction',\n                '[[value]]': fraction\n              });\n            }\n          }\n    } // a. Else if p is equal \"plusSign\", then:\n    else if (p === \"plusSign\") {\n        // i. Let plusSignSymbol be the ILND String representing the plus sign.\n        var plusSignSymbol = ild.plusSign; // ii. Add new part record { [[type]]: \"plusSign\", [[value]]: plusSignSymbol } as a new element of the list result.\n\n        arrPush.call(result, {\n          '[[type]]': 'plusSign',\n          '[[value]]': plusSignSymbol\n        });\n      } // a. Else if p is equal \"minusSign\", then:\n      else if (p === \"minusSign\") {\n          // i. Let minusSignSymbol be the ILND String representing the minus sign.\n          var minusSignSymbol = ild.minusSign; // ii. Add new part record { [[type]]: \"minusSign\", [[value]]: minusSignSymbol } as a new element of the list result.\n\n          arrPush.call(result, {\n            '[[type]]': 'minusSign',\n            '[[value]]': minusSignSymbol\n          });\n        } // a. Else if p is equal \"percentSign\" and numberFormat.[[style]] is \"percent\", then:\n        else if (p === \"percentSign\" && internal['[[style]]'] === \"percent\") {\n            // i. Let percentSignSymbol be the ILND String representing the percent sign.\n            var percentSignSymbol = ild.percentSign; // ii. Add new part record { [[type]]: \"percentSign\", [[value]]: percentSignSymbol } as a new element of the list result.\n\n            arrPush.call(result, {\n              '[[type]]': 'literal',\n              '[[value]]': percentSignSymbol\n            });\n          } // a. Else if p is equal \"currency\" and numberFormat.[[style]] is \"currency\", then:\n          else if (p === \"currency\" && internal['[[style]]'] === \"currency\") {\n              // i. Let currency be the value of numberFormat.[[currency]].\n              var currency = internal['[[currency]]'];\n              var cd = void 0; // ii. If numberFormat.[[currencyDisplay]] is \"code\", then\n\n              if (internal['[[currencyDisplay]]'] === \"code\") {\n                // 1. Let cd be currency.\n                cd = currency;\n              } // iii. Else if numberFormat.[[currencyDisplay]] is \"symbol\", then\n              else if (internal['[[currencyDisplay]]'] === \"symbol\") {\n                  // 1. Let cd be an ILD string representing currency in short form. If the implementation does not have such a representation of currency, use currency itself.\n                  cd = data.currencies[currency] || currency;\n                } // iv. Else if numberFormat.[[currencyDisplay]] is \"name\", then\n                else if (internal['[[currencyDisplay]]'] === \"name\") {\n                    // 1. Let cd be an ILD string representing currency in long form. If the implementation does not have such a representation of currency, then use currency itself.\n                    cd = currency;\n                  } // v. Add new part record { [[type]]: \"currency\", [[value]]: cd } as a new element of the list result.\n\n\n              arrPush.call(result, {\n                '[[type]]': 'currency',\n                '[[value]]': cd\n              });\n            } // a. Else,\n            else {\n                // i. Let literal be the substring of pattern from position beginIndex, inclusive, to position endIndex, inclusive.\n                var _literal = pattern.substring(beginIndex, endIndex); // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n\n\n                arrPush.call(result, {\n                  '[[type]]': 'literal',\n                  '[[value]]': _literal\n                });\n              } // a. Set nextIndex to endIndex + 1.\n\n\n    nextIndex = endIndex + 1; // a. Set beginIndex to Call(%StringProto_indexOf%, pattern, \"{\", nextIndex)\n\n    beginIndex = pattern.indexOf('{', nextIndex);\n  } // 9. If nextIndex is less than length, then:\n\n\n  if (nextIndex < length) {\n    // a. Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\n    var _literal2 = pattern.substring(nextIndex, length); // a. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n\n\n    arrPush.call(result, {\n      '[[type]]': 'literal',\n      '[[value]]': _literal2\n    });\n  } // 10. Return result.\n\n\n  return result;\n}\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-formatnumber]\n */\n\n\nfunction FormatNumber(numberFormat, x) {\n  // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n  var parts = PartitionNumberPattern(numberFormat, x); // 2. Let result be an empty String.\n\n  var result = ''; // 3. For each part in parts, do:\n\n  for (var i = 0; parts.length > i; i++) {\n    var part = parts[i]; // a. Set result to a String value produced by concatenating result and part.[[value]].\n\n    result += part['[[value]]'];\n  } // 4. Return result.\n\n\n  return result;\n}\n/**\n * When the ToRawPrecision abstract operation is called with arguments x (which\n * must be a finite non-negative number), minPrecision, and maxPrecision (both\n * must be integers between 1 and 21) the following steps are taken:\n */\n\n\nfunction ToRawPrecision(x, minPrecision, maxPrecision) {\n  // 1. Let p be maxPrecision.\n  var p = maxPrecision;\n  var m = void 0,\n      e = void 0; // 2. If x = 0, then\n\n  if (x === 0) {\n    // a. Let m be the String consisting of p occurrences of the character \"0\".\n    m = arrJoin.call(Array(p + 1), '0'); // b. Let e be 0.\n\n    e = 0;\n  } // 3. Else\n  else {\n      // a. Let e and n be integers such that 10ᵖ⁻¹ ≤ n < 10ᵖ and for which the\n      //    exact mathematical value of n × 10ᵉ⁻ᵖ⁺¹ – x is as close to zero as\n      //    possible. If there are two such sets of e and n, pick the e and n for\n      //    which n × 10ᵉ⁻ᵖ⁺¹ is larger.\n      e = log10Floor(Math.abs(x)); // Easier to get to m from here\n\n      var f = Math.round(Math.exp(Math.abs(e - p + 1) * Math.LN10)); // b. Let m be the String consisting of the digits of the decimal\n      //    representation of n (in order, with no leading zeroes)\n\n      m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n    } // 4. If e ≥ p, then\n\n\n  if (e >= p) // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n    return m + arrJoin.call(Array(e - p + 1 + 1), '0'); // 5. If e = p-1, then\n  else if (e === p - 1) // a. Return m.\n      return m; // 6. If e ≥ 0, then\n    else if (e >= 0) // a. Let m be the concatenation of the first e+1 characters of m, the character\n        //    \".\", and the remaining p–(e+1) characters of m.\n        m = m.slice(0, e + 1) + '.' + m.slice(e + 1); // 7. If e < 0, then\n      else if (e < 0) // a. Let m be the concatenation of the String \"0.\", –(e+1) occurrences of the\n          //    character \"0\", and the string m.\n          m = '0.' + arrJoin.call(Array(-(e + 1) + 1), '0') + m; // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n\n  if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n    // a. Let cut be maxPrecision – minPrecision.\n    var cut = maxPrecision - minPrecision; // b. Repeat while cut > 0 and the last character of m is \"0\":\n\n    while (cut > 0 && m.charAt(m.length - 1) === '0') {\n      //  i. Remove the last character from m.\n      m = m.slice(0, -1); //  ii. Decrease cut by 1.\n\n      cut--;\n    } // c. If the last character of m is \".\", then\n\n\n    if (m.charAt(m.length - 1) === '.') //    i. Remove the last character from m.\n      m = m.slice(0, -1);\n  } // 9. Return m.\n\n\n  return m;\n}\n/**\n * @spec[tc39/ecma402/master/spec/numberformat.html]\n * @clause[sec-torawfixed]\n * When the ToRawFixed abstract operation is called with arguments x (which must\n * be a finite non-negative number), minInteger (which must be an integer between\n * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n * 20) the following steps are taken:\n */\n\n\nfunction ToRawFixed(x, minInteger, minFraction, maxFraction) {\n  // 1. Let f be maxFraction.\n  var f = maxFraction; // 2. Let n be an integer for which the exact mathematical value of n ÷ 10f – x is as close to zero as possible. If there are two such n, pick the larger n.\n\n  var n = Math.pow(10, f) * x; // diverging...\n  // 3. If n = 0, let m be the String \"0\". Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes).\n\n  var m = n === 0 ? \"0\" : n.toFixed(0); // divering...\n\n  {\n    // this diversion is needed to take into consideration big numbers, e.g.:\n    // 1.2344501e+37 -> 12344501000000000000000000000000000000\n    var idx = void 0;\n    var exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n\n    if (exp) {\n      m = m.slice(0, idx).replace('.', '');\n      m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0');\n    }\n  }\n  var int = void 0; // 4. If f ≠ 0, then\n\n  if (f !== 0) {\n    // a. Let k be the number of characters in m.\n    var k = m.length; // a. If k ≤ f, then\n\n    if (k <= f) {\n      // i. Let z be the String consisting of f+1–k occurrences of the character \"0\".\n      var z = arrJoin.call(Array(f + 1 - k + 1), '0'); // ii. Let m be the concatenation of Strings z and m.\n\n      m = z + m; // iii. Let k be f+1.\n\n      k = f + 1;\n    } // a. Let a be the first k–f characters of m, and let b be the remaining f characters of m.\n\n\n    var a = m.substring(0, k - f),\n        b = m.substring(k - f, m.length); // a. Let m be the concatenation of the three Strings a, \".\", and b.\n\n    m = a + \".\" + b; // a. Let int be the number of characters in a.\n\n    int = a.length;\n  } // 5. Else, let int be the number of characters in m.\n  else int = m.length; // 6. Let cut be maxFraction – minFraction.\n\n\n  var cut = maxFraction - minFraction; // 7. Repeat while cut > 0 and the last character of m is \"0\":\n\n  while (cut > 0 && m.slice(-1) === \"0\") {\n    // a. Remove the last character from m.\n    m = m.slice(0, -1); // a. Decrease cut by 1.\n\n    cut--;\n  } // 8. If the last character of m is \".\", then\n\n\n  if (m.slice(-1) === \".\") {\n    // a. Remove the last character from m.\n    m = m.slice(0, -1);\n  } // 9. If int < minInteger, then\n\n\n  if (int < minInteger) {\n    // a. Let z be the String consisting of minInteger–int occurrences of the character \"0\".\n    var _z = arrJoin.call(Array(minInteger - int + 1), '0'); // a. Let m be the concatenation of Strings z and m.\n\n\n    m = _z + m;\n  } // 10. Return m.\n\n\n  return m;\n} // Sect 11.3.2 Table 2, Numbering systems\n// ======================================\n\n\nvar numSys = {\n  arab: [\"٠\", \"١\", \"٢\", \"٣\", \"٤\", \"٥\", \"٦\", \"٧\", \"٨\", \"٩\"],\n  arabext: [\"۰\", \"۱\", \"۲\", \"۳\", \"۴\", \"۵\", \"۶\", \"۷\", \"۸\", \"۹\"],\n  bali: [\"᭐\", \"᭑\", \"᭒\", \"᭓\", \"᭔\", \"᭕\", \"᭖\", \"᭗\", \"᭘\", \"᭙\"],\n  beng: [\"০\", \"১\", \"২\", \"৩\", \"৪\", \"৫\", \"৬\", \"৭\", \"৮\", \"৯\"],\n  deva: [\"०\", \"१\", \"२\", \"३\", \"४\", \"५\", \"६\", \"७\", \"८\", \"९\"],\n  fullwide: [\"０\", \"１\", \"２\", \"３\", \"４\", \"５\", \"６\", \"７\", \"８\", \"９\"],\n  gujr: [\"૦\", \"૧\", \"૨\", \"૩\", \"૪\", \"૫\", \"૬\", \"૭\", \"૮\", \"૯\"],\n  guru: [\"੦\", \"੧\", \"੨\", \"੩\", \"੪\", \"੫\", \"੬\", \"੭\", \"੮\", \"੯\"],\n  hanidec: [\"〇\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"],\n  khmr: [\"០\", \"១\", \"២\", \"៣\", \"៤\", \"៥\", \"៦\", \"៧\", \"៨\", \"៩\"],\n  knda: [\"೦\", \"೧\", \"೨\", \"೩\", \"೪\", \"೫\", \"೬\", \"೭\", \"೮\", \"೯\"],\n  laoo: [\"໐\", \"໑\", \"໒\", \"໓\", \"໔\", \"໕\", \"໖\", \"໗\", \"໘\", \"໙\"],\n  latn: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n  limb: [\"᥆\", \"᥇\", \"᥈\", \"᥉\", \"᥊\", \"᥋\", \"᥌\", \"᥍\", \"᥎\", \"᥏\"],\n  mlym: [\"൦\", \"൧\", \"൨\", \"൩\", \"൪\", \"൫\", \"൬\", \"൭\", \"൮\", \"൯\"],\n  mong: [\"᠐\", \"᠑\", \"᠒\", \"᠓\", \"᠔\", \"᠕\", \"᠖\", \"᠗\", \"᠘\", \"᠙\"],\n  mymr: [\"၀\", \"၁\", \"၂\", \"၃\", \"၄\", \"၅\", \"၆\", \"၇\", \"၈\", \"၉\"],\n  orya: [\"୦\", \"୧\", \"୨\", \"୩\", \"୪\", \"୫\", \"୬\", \"୭\", \"୮\", \"୯\"],\n  tamldec: [\"௦\", \"௧\", \"௨\", \"௩\", \"௪\", \"௫\", \"௬\", \"௭\", \"௮\", \"௯\"],\n  telu: [\"౦\", \"౧\", \"౨\", \"౩\", \"౪\", \"౫\", \"౬\", \"౭\", \"౮\", \"౯\"],\n  thai: [\"๐\", \"๑\", \"๒\", \"๓\", \"๔\", \"๕\", \"๖\", \"๗\", \"๘\", \"๙\"],\n  tibt: [\"༠\", \"༡\", \"༢\", \"༣\", \"༤\", \"༥\", \"༦\", \"༧\", \"༨\", \"༩\"]\n};\n/**\n * This function provides access to the locale and formatting options computed\n * during initialization of the object.\n *\n * The function returns a new object whose properties and attributes are set as\n * if constructed by an object literal assigning to each of the following\n * properties the value of the corresponding internal property of this\n * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n * useGrouping. Properties whose corresponding internal properties are not present\n * are not assigned.\n */\n\n/* 11.3.3 */\n\ndefineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n  configurable: true,\n  writable: true,\n  value: function value() {\n    var prop = void 0,\n        descs = new Record(),\n        props = ['locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'],\n        internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this); // Satisfy test 11.3_b\n\n    if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\n    for (var i = 0, max = props.length; i < max; i++) {\n      if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = {\n        value: internal[prop],\n        writable: true,\n        configurable: true,\n        enumerable: true\n      };\n    }\n\n    return objCreate({}, descs);\n  }\n});\n/* jslint esnext: true */\n// Match these datetime components in a CLDR pattern, except those in single quotes\n\nvar expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g; // trim patterns after transformations\n\nvar expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g; // Skip over patterns with these datetime components because we don't have data\n// to back them up:\n// timezone, weekday, amoung others\n\nvar unwantedDTCs = /[rqQASjJgwWIQq]/; // xXVO were removed from this list in favor of computing matches with timeZoneName values but printing as empty string\n\nvar dtKeys = [\"era\", \"year\", \"month\", \"day\", \"weekday\", \"quarter\"];\nvar tmKeys = [\"hour\", \"minute\", \"second\", \"hour12\", \"timeZoneName\"];\n\nfunction isDateFormatOnly(obj) {\n  for (var i = 0; i < tmKeys.length; i += 1) {\n    if (obj.hasOwnProperty(tmKeys[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isTimeFormatOnly(obj) {\n  for (var i = 0; i < dtKeys.length; i += 1) {\n    if (obj.hasOwnProperty(dtKeys[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {\n  var o = {\n    _: {}\n  };\n\n  for (var i = 0; i < dtKeys.length; i += 1) {\n    if (dateFormatObj[dtKeys[i]]) {\n      o[dtKeys[i]] = dateFormatObj[dtKeys[i]];\n    }\n\n    if (dateFormatObj._[dtKeys[i]]) {\n      o._[dtKeys[i]] = dateFormatObj._[dtKeys[i]];\n    }\n  }\n\n  for (var j = 0; j < tmKeys.length; j += 1) {\n    if (timeFormatObj[tmKeys[j]]) {\n      o[tmKeys[j]] = timeFormatObj[tmKeys[j]];\n    }\n\n    if (timeFormatObj._[tmKeys[j]]) {\n      o._[tmKeys[j]] = timeFormatObj._[tmKeys[j]];\n    }\n  }\n\n  return o;\n}\n\nfunction computeFinalPatterns(formatObj) {\n  // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n  //  'In patterns, two single quotes represents a literal single quote, either\n  //   inside or outside single quotes. Text within single quotes is not\n  //   interpreted in any way (except for two adjacent single quotes).'\n  formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, function ($0, literal) {\n    return literal ? literal : \"'\";\n  }); // pattern 12 is always the default. we can produce the 24 by removing {ampm}\n\n  formatObj.pattern = formatObj.pattern12.replace('{ampm}', '').replace(expPatternTrimmer, '');\n  return formatObj;\n}\n\nfunction expDTComponentsMeta($0, formatObj) {\n  switch ($0.charAt(0)) {\n    // --- Era\n    case 'G':\n      formatObj.era = ['short', 'short', 'short', 'long', 'narrow'][$0.length - 1];\n      return '{era}';\n    // --- Year\n\n    case 'y':\n    case 'Y':\n    case 'u':\n    case 'U':\n    case 'r':\n      formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{year}';\n    // --- Quarter (not supported in this polyfill)\n\n    case 'Q':\n    case 'q':\n      formatObj.quarter = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n      return '{quarter}';\n    // --- Month\n\n    case 'M':\n    case 'L':\n      formatObj.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n      return '{month}';\n    // --- Week (not supported in this polyfill)\n\n    case 'w':\n      // week of the year\n      formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{weekday}';\n\n    case 'W':\n      // week of the month\n      formatObj.week = 'numeric';\n      return '{weekday}';\n    // --- Day\n\n    case 'd':\n      // day of the month\n      formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{day}';\n\n    case 'D': // day of the year\n\n    case 'F': // day of the week\n\n    case 'g':\n      // 1..n: Modified Julian day\n      formatObj.day = 'numeric';\n      return '{day}';\n    // --- Week Day\n\n    case 'E':\n      // day of the week\n      formatObj.weekday = ['short', 'short', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n      return '{weekday}';\n\n    case 'e':\n      // local day of the week\n      formatObj.weekday = ['numeric', '2-digit', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n      return '{weekday}';\n\n    case 'c':\n      // stand alone local day of the week\n      formatObj.weekday = ['numeric', undefined, 'short', 'long', 'narrow', 'short'][$0.length - 1];\n      return '{weekday}';\n    // --- Period\n\n    case 'a': // AM, PM\n\n    case 'b': // am, pm, noon, midnight\n\n    case 'B':\n      // flexible day periods\n      formatObj.hour12 = true;\n      return '{ampm}';\n    // --- Hour\n\n    case 'h':\n    case 'H':\n      formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{hour}';\n\n    case 'k':\n    case 'K':\n      formatObj.hour12 = true; // 12-hour-cycle time formats (using h or K)\n\n      formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{hour}';\n    // --- Minute\n\n    case 'm':\n      formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{minute}';\n    // --- Second\n\n    case 's':\n      formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n      return '{second}';\n\n    case 'S':\n    case 'A':\n      formatObj.second = 'numeric';\n      return '{second}';\n    // --- Timezone\n\n    case 'z': // 1..3, 4: specific non-location format\n\n    case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n\n    case 'O': // 1, 4: miliseconds in day short, long\n\n    case 'v': // 1, 4: generic non-location format\n\n    case 'V': // 1, 2, 3, 4: time zone ID or city\n\n    case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n\n    case 'x':\n      // 1, 2, 3, 4: The ISO8601 varios formats\n      // this polyfill only supports much, for now, we are just doing something dummy\n      formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n      return '{timeZoneName}';\n  }\n}\n/**\n * Converts the CLDR availableFormats into the objects and patterns required by\n * the ECMAScript Internationalization API specification.\n */\n\n\nfunction createDateTimeFormat(skeleton, pattern) {\n  // we ignore certain patterns that are unsupported to avoid this expensive op.\n  if (unwantedDTCs.test(pattern)) return undefined;\n  var formatObj = {\n    originalPattern: pattern,\n    _: {}\n  }; // Replace the pattern string with the one required by the specification, whilst\n  // at the same time evaluating it for the subsets and formats\n\n  formatObj.extendedPattern = pattern.replace(expDTComponents, function ($0) {\n    // See which symbol we're dealing with\n    return expDTComponentsMeta($0, formatObj._);\n  }); // Match the skeleton string with the one required by the specification\n  // this implementation is based on the Date Field Symbol Table:\n  // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n  // Note: we are adding extra data to the formatObject even though this polyfill\n  //       might not support it.\n\n  skeleton.replace(expDTComponents, function ($0) {\n    // See which symbol we're dealing with\n    return expDTComponentsMeta($0, formatObj);\n  });\n  return computeFinalPatterns(formatObj);\n}\n/**\n * Processes DateTime formats from CLDR to an easier-to-parse format.\n * the result of this operation should be cached the first time a particular\n * calendar is analyzed.\n *\n * The specification requires we support at least the following subsets of\n * date/time components:\n *\n *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\n *   - 'weekday', 'year', 'month', 'day'\n *   - 'year', 'month', 'day'\n *   - 'year', 'month'\n *   - 'month', 'day'\n *   - 'hour', 'minute', 'second'\n *   - 'hour', 'minute'\n *\n * We need to cherry pick at least these subsets from the CLDR data and convert\n * them into the pattern objects used in the ECMA-402 API.\n */\n\n\nfunction createDateTimeFormats(formats) {\n  var availableFormats = formats.availableFormats;\n  var timeFormats = formats.timeFormats;\n  var dateFormats = formats.dateFormats;\n  var result = [];\n  var skeleton = void 0,\n      pattern = void 0,\n      computed = void 0,\n      i = void 0,\n      j = void 0;\n  var timeRelatedFormats = [];\n  var dateRelatedFormats = []; // Map available (custom) formats into a pattern for createDateTimeFormats\n\n  for (skeleton in availableFormats) {\n    if (availableFormats.hasOwnProperty(skeleton)) {\n      pattern = availableFormats[skeleton];\n      computed = createDateTimeFormat(skeleton, pattern);\n\n      if (computed) {\n        result.push(computed); // in some cases, the format is only displaying date specific props\n        // or time specific props, in which case we need to also produce the\n        // combined formats.\n\n        if (isDateFormatOnly(computed)) {\n          dateRelatedFormats.push(computed);\n        } else if (isTimeFormatOnly(computed)) {\n          timeRelatedFormats.push(computed);\n        }\n      }\n    }\n  } // Map time formats into a pattern for createDateTimeFormats\n\n\n  for (skeleton in timeFormats) {\n    if (timeFormats.hasOwnProperty(skeleton)) {\n      pattern = timeFormats[skeleton];\n      computed = createDateTimeFormat(skeleton, pattern);\n\n      if (computed) {\n        result.push(computed);\n        timeRelatedFormats.push(computed);\n      }\n    }\n  } // Map date formats into a pattern for createDateTimeFormats\n\n\n  for (skeleton in dateFormats) {\n    if (dateFormats.hasOwnProperty(skeleton)) {\n      pattern = dateFormats[skeleton];\n      computed = createDateTimeFormat(skeleton, pattern);\n\n      if (computed) {\n        result.push(computed);\n        dateRelatedFormats.push(computed);\n      }\n    }\n  } // combine custom time and custom date formats when they are orthogonals to complete the\n  // formats supported by CLDR.\n  // This Algo is based on section \"Missing Skeleton Fields\" from:\n  // http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n\n\n  for (i = 0; i < timeRelatedFormats.length; i += 1) {\n    for (j = 0; j < dateRelatedFormats.length; j += 1) {\n      if (dateRelatedFormats[j].month === 'long') {\n        pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;\n      } else if (dateRelatedFormats[j].month === 'short') {\n        pattern = formats.medium;\n      } else {\n        pattern = formats.short;\n      }\n\n      computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i]);\n      computed.originalPattern = pattern;\n      computed.extendedPattern = pattern.replace('{0}', timeRelatedFormats[i].extendedPattern).replace('{1}', dateRelatedFormats[j].extendedPattern).replace(/^[,\\s]+|[,\\s]+$/gi, '');\n      result.push(computeFinalPatterns(computed));\n    }\n  }\n\n  return result;\n} // this represents the exceptions of the rule that are not covered by CLDR availableFormats\n// for single property configurations, they play no role when using multiple properties, and\n// those that are not in this table, are not exceptions or are not covered by the data we\n// provide.\n\n\nvar validSyntheticProps = {\n  second: {\n    numeric: 's',\n    '2-digit': 'ss'\n  },\n  minute: {\n    numeric: 'm',\n    '2-digit': 'mm'\n  },\n  year: {\n    numeric: 'y',\n    '2-digit': 'yy'\n  },\n  day: {\n    numeric: 'd',\n    '2-digit': 'dd'\n  },\n  month: {\n    numeric: 'L',\n    '2-digit': 'LL',\n    narrow: 'LLLLL',\n    short: 'LLL',\n    long: 'LLLL'\n  },\n  weekday: {\n    narrow: 'ccccc',\n    short: 'ccc',\n    long: 'cccc'\n  }\n};\n\nfunction generateSyntheticFormat(propName, propValue) {\n  if (validSyntheticProps[propName] && validSyntheticProps[propName][propValue]) {\n    var _ref2;\n\n    return _ref2 = {\n      originalPattern: validSyntheticProps[propName][propValue],\n      _: defineProperty$1({}, propName, propValue),\n      extendedPattern: \"{\" + propName + \"}\"\n    }, defineProperty$1(_ref2, propName, propValue), defineProperty$1(_ref2, \"pattern12\", \"{\" + propName + \"}\"), defineProperty$1(_ref2, \"pattern\", \"{\" + propName + \"}\"), _ref2;\n  }\n} // An object map of date component keys, saves using a regex later\n\n\nvar dateWidths = objCreate(null, {\n  narrow: {},\n  short: {},\n  long: {}\n});\n/**\n * Returns a string for a date component, resolved using multiple inheritance as specified\n * as specified in the Unicode Technical Standard 35.\n */\n\nfunction resolveDateString(data, ca, component, width, key) {\n  // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n  // 'In clearly specified instances, resources may inherit from within the same locale.\n  //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n  var obj = data[ca] && data[ca][component] ? data[ca][component] : data.gregory[component],\n      // \"sideways\" inheritance resolves strings when a key doesn't exist\n  alts = {\n    narrow: ['short', 'long'],\n    short: ['long', 'narrow'],\n    long: ['short', 'narrow']\n  },\n      //\n  resolved = hop.call(obj, width) ? obj[width] : hop.call(obj, alts[width][0]) ? obj[alts[width][0]] : obj[alts[width][1]]; // `key` wouldn't be specified for components 'dayPeriods'\n\n  return key !== null ? resolved[key] : resolved;\n} // Define the DateTimeFormat constructor internally so it cannot be tainted\n\n\nfunction DateTimeFormatConstructor() {\n  var locales = arguments[0];\n  var options = arguments[1];\n\n  if (!this || this === Intl) {\n    return new Intl.DateTimeFormat(locales, options);\n  }\n\n  return InitializeDateTimeFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'DateTimeFormat', {\n  configurable: true,\n  writable: true,\n  value: DateTimeFormatConstructor\n}); // Must explicitly set prototypes as unwritable\n\ndefineProperty(DateTimeFormatConstructor, 'prototype', {\n  writable: false\n});\n/**\n * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n * DateTimeFormat object.\n */\n\nfunction\n/* 12.1.1.1 */\nInitializeDateTimeFormat(dateTimeFormat, locales, options) {\n  // This will be a internal properties object if we're not already initialized\n  var internal = getInternalProperties(dateTimeFormat); // Create an object whose props can be used to restore the values of RegExp props\n\n  var regexpRestore = createRegExpRestore(); // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n  //    value true, throw a TypeError exception.\n\n  if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object'); // Need this to access the `internal` object\n\n  defineProperty(dateTimeFormat, '__getInternalProperties', {\n    value: function value() {\n      // NOTE: Non-standard, for internal use only\n      if (arguments[0] === secret) return internal;\n    }\n  }); // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n\n  internal['[[initializedIntlObject]]'] = true; // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n  //    abstract operation (defined in 9.2.1) with argument locales.\n\n  var requestedLocales = CanonicalizeLocaleList(locales); // 4. Let options be the result of calling the ToDateTimeOptions abstract\n  //    operation (defined below) with arguments options, \"any\", and \"date\".\n\n  options = ToDateTimeOptions(options, 'any', 'date'); // 5. Let opt be a new Record.\n\n  var opt = new Record(); // 6. Let matcher be the result of calling the GetOption abstract operation\n  //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n  //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n\n  var matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit'); // 7. Set opt.[[localeMatcher]] to matcher.\n\n  opt['[[localeMatcher]]'] = matcher; // 8. Let DateTimeFormat be the standard built-in object that is the initial\n  //    value of Intl.DateTimeFormat.\n\n  var DateTimeFormat = internals.DateTimeFormat; // This is what we *really* need\n  // 9. Let localeData be the value of the [[localeData]] internal property of\n  //    DateTimeFormat.\n\n  var localeData = DateTimeFormat['[[localeData]]']; // 10. Let r be the result of calling the ResolveLocale abstract operation\n  //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n  //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n  //      internal property of DateTimeFormat, and localeData.\n\n  var r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales, opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData); // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n  //     r.[[locale]].\n\n  internal['[[locale]]'] = r['[[locale]]']; // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n  //     r.[[ca]].\n\n  internal['[[calendar]]'] = r['[[ca]]']; // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n  //     r.[[nu]].\n\n  internal['[[numberingSystem]]'] = r['[[nu]]']; // The specification doesn't tell us to do this, but it's helpful later on\n\n  internal['[[dataLocale]]'] = r['[[dataLocale]]']; // 14. Let dataLocale be the value of r.[[dataLocale]].\n\n  var dataLocale = r['[[dataLocale]]']; // 15. Let tz be the result of calling the [[Get]] internal method of options with\n  //     argument \"timeZone\".\n\n  var tz = options.timeZone; // 16. If tz is not undefined, then\n\n  if (tz !== undefined) {\n    // a. Let tz be ToString(tz).\n    // b. Convert tz to upper case as described in 6.1.\n    //    NOTE: If an implementation accepts additional time zone values, as permitted\n    //          under certain conditions by the Conformance clause, different casing\n    //          rules apply.\n    tz = toLatinUpperCase(tz); // c. If tz is not \"UTC\", then throw a RangeError exception.\n    // ###TODO: accept more time zones###\n\n    if (tz !== 'UTC') throw new RangeError('timeZone is not supported.');\n  } // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n\n\n  internal['[[timeZone]]'] = tz; // 18. Let opt be a new Record.\n\n  opt = new Record(); // 19. For each row of Table 3, except the header row, do:\n\n  for (var prop in dateTimeComponents) {\n    if (!hop.call(dateTimeComponents, prop)) continue; // 20. Let prop be the name given in the Property column of the row.\n    // 21. Let value be the result of calling the GetOption abstract operation,\n    //     passing as argument options, the name given in the Property column of the\n    //     row, \"string\", a List containing the strings given in the Values column of\n    //     the row, and undefined.\n\n    var value = GetOption(options, prop, 'string', dateTimeComponents[prop]); // 22. Set opt.[[<prop>]] to value.\n\n    opt['[[' + prop + ']]'] = value;\n  } // Assigned a value below\n\n\n  var bestFormat = void 0; // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n  //     localeData with argument dataLocale.\n\n  var dataLocaleData = localeData[dataLocale]; // 24. Let formats be the result of calling the [[Get]] internal method of\n  //     dataLocaleData with argument \"formats\".\n  //     Note: we process the CLDR formats into the spec'd structure\n\n  var formats = ToDateTimeFormats(dataLocaleData.formats); // 25. Let matcher be the result of calling the GetOption abstract operation with\n  //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n  //     values \"basic\" and \"best fit\", and \"best fit\".\n\n  matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit'); // Optimization: caching the processed formats as a one time operation by\n  // replacing the initial structure from localeData\n\n  dataLocaleData.formats = formats; // 26. If matcher is \"basic\", then\n\n  if (matcher === 'basic') {\n    // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n    //     operation (defined below) with opt and formats.\n    bestFormat = BasicFormatMatcher(opt, formats); // 28. Else\n  } else {\n    {\n      // diverging\n      var _hr = GetOption(options, 'hour12', 'boolean'\n      /*, undefined, undefined*/\n      );\n\n      opt.hour12 = _hr === undefined ? dataLocaleData.hour12 : _hr;\n    } // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n    //     abstract operation (defined below) with opt and formats.\n\n    bestFormat = BestFitFormatMatcher(opt, formats);\n  } // 30. For each row in Table 3, except the header row, do\n\n\n  for (var _prop in dateTimeComponents) {\n    if (!hop.call(dateTimeComponents, _prop)) continue; // a. Let prop be the name given in the Property column of the row.\n    // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n    //    bestFormat with argument prop.\n    // c. If pDesc is not undefined, then\n\n    if (hop.call(bestFormat, _prop)) {\n      // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n      //    with argument prop.\n      var p = bestFormat[_prop];\n      {\n        // diverging\n        p = bestFormat._ && hop.call(bestFormat._, _prop) ? bestFormat._[_prop] : p;\n      } // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n\n      internal['[[' + _prop + ']]'] = p;\n    }\n  }\n\n  var pattern = void 0; // Assigned a value below\n  // 31. Let hr12 be the result of calling the GetOption abstract operation with\n  //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n\n  var hr12 = GetOption(options, 'hour12', 'boolean'\n  /*, undefined, undefined*/\n  ); // 32. If dateTimeFormat has an internal property [[hour]], then\n\n  if (internal['[[hour]]']) {\n    // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n    //    internal method of dataLocaleData with argument \"hour12\".\n    hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12; // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n\n    internal['[[hour12]]'] = hr12; // c. If hr12 is true, then\n\n    if (hr12 === true) {\n      // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n      //    dataLocaleData with argument \"hourNo0\".\n      var hourNo0 = dataLocaleData.hourNo0; // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n\n      internal['[[hourNo0]]'] = hourNo0; // iii. Let pattern be the result of calling the [[Get]] internal method of\n      //      bestFormat with argument \"pattern12\".\n\n      pattern = bestFormat.pattern12;\n    } // d. Else\n    else // i. Let pattern be the result of calling the [[Get]] internal method of\n      //    bestFormat with argument \"pattern\".\n      pattern = bestFormat.pattern;\n  } // 33. Else\n  else // a. Let pattern be the result of calling the [[Get]] internal method of\n    //    bestFormat with argument \"pattern\".\n    pattern = bestFormat.pattern; // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n\n\n  internal['[[pattern]]'] = pattern; // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n\n  internal['[[boundFormat]]'] = undefined; // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n  //     true.\n\n  internal['[[initializedDateTimeFormat]]'] = true; // In ES3, we need to pre-bind the format() function\n\n  if (es3) dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat); // Restore the RegExp properties\n\n  regexpRestore(); // Return the newly initialised object\n\n  return dateTimeFormat;\n}\n/**\n * Several DateTimeFormat algorithms use values from the following table, which provides\n * property names and allowable values for the components of date and time formats:\n */\n\n\nvar dateTimeComponents = {\n  weekday: [\"narrow\", \"short\", \"long\"],\n  era: [\"narrow\", \"short\", \"long\"],\n  year: [\"2-digit\", \"numeric\"],\n  month: [\"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\"],\n  day: [\"2-digit\", \"numeric\"],\n  hour: [\"2-digit\", \"numeric\"],\n  minute: [\"2-digit\", \"numeric\"],\n  second: [\"2-digit\", \"numeric\"],\n  timeZoneName: [\"short\", \"long\"]\n};\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\n\nfunction ToDateTimeFormats(formats) {\n  if (Object.prototype.toString.call(formats) === '[object Array]') {\n    return formats;\n  }\n\n  return createDateTimeFormats(formats);\n}\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\n\n\nfunction ToDateTimeOptions(options, required, defaults) {\n  // 1. If options is undefined, then let options be null, else let options be\n  //    ToObject(options).\n  if (options === undefined) options = null;else {\n    // (#12) options needs to be a Record, but it also needs to inherit properties\n    var opt2 = toObject(options);\n    options = new Record();\n\n    for (var k in opt2) {\n      options[k] = opt2[k];\n    }\n  } // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n\n  var create = objCreate; // 3. Let options be the result of calling the [[Call]] internal method of create with\n  //    undefined as the this value and an argument list containing the single item\n  //    options.\n\n  options = create(options); // 4. Let needDefaults be true.\n\n  var needDefaults = true; // 5. If required is \"date\" or \"any\", then\n\n  if (required === 'date' || required === 'any') {\n    // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n    // i. If the result of calling the [[Get]] internal method of options with the\n    //    property name is not undefined, then let needDefaults be false.\n    if (options.weekday !== undefined || options.year !== undefined || options.month !== undefined || options.day !== undefined) needDefaults = false;\n  } // 6. If required is \"time\" or \"any\", then\n\n\n  if (required === 'time' || required === 'any') {\n    // a. For each of the property names \"hour\", \"minute\", \"second\":\n    // i. If the result of calling the [[Get]] internal method of options with the\n    //    property name is not undefined, then let needDefaults be false.\n    if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined) needDefaults = false;\n  } // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n\n\n  if (needDefaults && (defaults === 'date' || defaults === 'all')) // a. For each of the property names \"year\", \"month\", \"day\":\n    // i. Call the [[DefineOwnProperty]] internal method of options with the\n    //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n    //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n    options.year = options.month = options.day = 'numeric'; // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n\n  if (needDefaults && (defaults === 'time' || defaults === 'all')) // a. For each of the property names \"hour\", \"minute\", \"second\":\n    // i. Call the [[DefineOwnProperty]] internal method of options with the\n    //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n    //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n    options.hour = options.minute = options.second = 'numeric'; // 9. Return options.\n\n  return options;\n}\n/**\n * When the BasicFormatMatcher abstract operation is called with two arguments options and\n * formats, the following steps are taken:\n */\n\n\nfunction BasicFormatMatcher(options, formats) {\n  // 1. Let removalPenalty be 120.\n  var removalPenalty = 120; // 2. Let additionPenalty be 20.\n\n  var additionPenalty = 20; // 3. Let longLessPenalty be 8.\n\n  var longLessPenalty = 8; // 4. Let longMorePenalty be 6.\n\n  var longMorePenalty = 6; // 5. Let shortLessPenalty be 6.\n\n  var shortLessPenalty = 6; // 6. Let shortMorePenalty be 3.\n\n  var shortMorePenalty = 3; // 7. Let bestScore be -Infinity.\n\n  var bestScore = -Infinity; // 8. Let bestFormat be undefined.\n\n  var bestFormat = void 0; // 9. Let i be 0.\n\n  var i = 0; // 10. Assert: formats is an Array object.\n  // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n\n  var len = formats.length; // 12. Repeat while i < len:\n\n  while (i < len) {\n    // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n    var format = formats[i]; // b. Let score be 0.\n\n    var score = 0; // c. For each property shown in Table 3:\n\n    for (var property in dateTimeComponents) {\n      if (!hop.call(dateTimeComponents, property)) continue; // i. Let optionsProp be options.[[<property>]].\n\n      var optionsProp = options['[[' + property + ']]']; // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n      //     with argument property.\n      // iii. If formatPropDesc is not undefined, then\n      //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n\n      var formatProp = hop.call(format, property) ? format[property] : undefined; // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n      //     additionPenalty.\n\n      if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty; // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n      //    removalPenalty.\n      else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty; // vi. Else\n        else {\n            // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n            //    \"long\"].\n            var values = ['2-digit', 'numeric', 'narrow', 'short', 'long']; // 2. Let optionsPropIndex be the index of optionsProp within values.\n\n            var optionsPropIndex = arrIndexOf.call(values, optionsProp); // 3. Let formatPropIndex be the index of formatProp within values.\n\n            var formatPropIndex = arrIndexOf.call(values, formatProp); // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n\n            var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2); // 5. If delta = 2, decrease score by longMorePenalty.\n\n            if (delta === 2) score -= longMorePenalty; // 6. Else if delta = 1, decrease score by shortMorePenalty.\n            else if (delta === 1) score -= shortMorePenalty; // 7. Else if delta = -1, decrease score by shortLessPenalty.\n              else if (delta === -1) score -= shortLessPenalty; // 8. Else if delta = -2, decrease score by longLessPenalty.\n                else if (delta === -2) score -= longLessPenalty;\n          }\n    } // d. If score > bestScore, then\n\n\n    if (score > bestScore) {\n      // i. Let bestScore be score.\n      bestScore = score; // ii. Let bestFormat be format.\n\n      bestFormat = format;\n    } // e. Increase i by 1.\n\n\n    i++;\n  } // 13. Return bestFormat.\n\n\n  return bestFormat;\n}\n/**\n * When the BestFitFormatMatcher abstract operation is called with two arguments options\n * and formats, it performs implementation dependent steps, which should return a set of\n * component representations that a typical user of the selected locale would perceive as\n * at least as good as the one returned by BasicFormatMatcher.\n *\n * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n * with the addition of bonus points awarded where the requested format is of\n * the same data type as the potentially matching format.\n *\n * This algo relies on the concept of closest distance matching described here:\n * http://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n * Typically a “best match” is found using a closest distance match, such as:\n *\n * Symbols requesting a best choice for the locale are replaced.\n *      j → one of {H, k, h, K}; C → one of {a, b, B}\n * -> Covered by cldr.js matching process\n *\n * For fields with symbols representing the same type (year, month, day, etc):\n *     Most symbols have a small distance from each other.\n *         M ≅ L; E ≅ c; a ≅ b ≅ B; H ≅ k ≅ h ≅ K; ...\n *     -> Covered by cldr.js matching process\n *\n *     Width differences among fields, other than those marking text vs numeric, are given small distance from each other.\n *         MMM ≅ MMMM\n *         MM ≅ M\n *     Numeric and text fields are given a larger distance from each other.\n *         MMM ≈ MM\n *     Symbols representing substantial differences (week of year vs week of month) are given much larger a distances from each other.\n *         d ≋ D; ...\n *     Missing or extra fields cause a match to fail. (But see Missing Skeleton Fields).\n *\n *\n * For example,\n *\n *     { month: 'numeric', day: 'numeric' }\n *\n * should match\n *\n *     { month: '2-digit', day: '2-digit' }\n *\n * rather than\n *\n *     { month: 'short', day: 'numeric' }\n *\n * This makes sense because a user requesting a formatted date with numeric parts would\n * not expect to see the returned format containing narrow, short or long part names\n */\n\n\nfunction BestFitFormatMatcher(options, formats) {\n  /** Diverging: this block implements the hack for single property configuration, eg.:\n   *\n   *      `new Intl.DateTimeFormat('en', {day: 'numeric'})`\n   *\n   * should produce a single digit with the day of the month. This is needed because\n   * CLDR `availableFormats` data structure doesn't cover these cases.\n   */\n  {\n    var optionsPropNames = [];\n\n    for (var property in dateTimeComponents) {\n      if (!hop.call(dateTimeComponents, property)) continue;\n\n      if (options['[[' + property + ']]'] !== undefined) {\n        optionsPropNames.push(property);\n      }\n    }\n\n    if (optionsPropNames.length === 1) {\n      var _bestFormat = generateSyntheticFormat(optionsPropNames[0], options['[[' + optionsPropNames[0] + ']]']);\n\n      if (_bestFormat) {\n        return _bestFormat;\n      }\n    }\n  } // 1. Let removalPenalty be 120.\n\n  var removalPenalty = 120; // 2. Let additionPenalty be 20.\n\n  var additionPenalty = 20; // 3. Let longLessPenalty be 8.\n\n  var longLessPenalty = 8; // 4. Let longMorePenalty be 6.\n\n  var longMorePenalty = 6; // 5. Let shortLessPenalty be 6.\n\n  var shortLessPenalty = 6; // 6. Let shortMorePenalty be 3.\n\n  var shortMorePenalty = 3;\n  var patternPenalty = 2;\n  var hour12Penalty = 1; // 7. Let bestScore be -Infinity.\n\n  var bestScore = -Infinity; // 8. Let bestFormat be undefined.\n\n  var bestFormat = void 0; // 9. Let i be 0.\n\n  var i = 0; // 10. Assert: formats is an Array object.\n  // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n\n  var len = formats.length; // 12. Repeat while i < len:\n\n  while (i < len) {\n    // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n    var format = formats[i]; // b. Let score be 0.\n\n    var score = 0; // c. For each property shown in Table 3:\n\n    for (var _property in dateTimeComponents) {\n      if (!hop.call(dateTimeComponents, _property)) continue; // i. Let optionsProp be options.[[<property>]].\n\n      var optionsProp = options['[[' + _property + ']]']; // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n      //     with argument property.\n      // iii. If formatPropDesc is not undefined, then\n      //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n\n      var formatProp = hop.call(format, _property) ? format[_property] : undefined; // Diverging: using the default properties produced by the pattern/skeleton\n      // to match it with user options, and apply a penalty\n\n      var patternProp = hop.call(format._, _property) ? format._[_property] : undefined;\n\n      if (optionsProp !== patternProp) {\n        score -= patternPenalty;\n      } // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n      //     additionPenalty.\n\n\n      if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty; // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n      //    removalPenalty.\n      else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty; // vi. Else\n        else {\n            // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n            //    \"long\"].\n            var values = ['2-digit', 'numeric', 'narrow', 'short', 'long']; // 2. Let optionsPropIndex be the index of optionsProp within values.\n\n            var optionsPropIndex = arrIndexOf.call(values, optionsProp); // 3. Let formatPropIndex be the index of formatProp within values.\n\n            var formatPropIndex = arrIndexOf.call(values, formatProp); // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n\n            var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n            {\n              // diverging from spec\n              // When the bestFit argument is true, subtract additional penalty where data types are not the same\n              if (formatPropIndex <= 1 && optionsPropIndex >= 2 || formatPropIndex >= 2 && optionsPropIndex <= 1) {\n                // 5. If delta = 2, decrease score by longMorePenalty.\n                if (delta > 0) score -= longMorePenalty;else if (delta < 0) score -= longLessPenalty;\n              } else {\n                // 5. If delta = 2, decrease score by longMorePenalty.\n                if (delta > 1) score -= shortMorePenalty;else if (delta < -1) score -= shortLessPenalty;\n              }\n            }\n          }\n    }\n\n    {\n      // diverging to also take into consideration differences between 12 or 24 hours\n      // which is special for the best fit only.\n      if (format._.hour12 !== options.hour12) {\n        score -= hour12Penalty;\n      }\n    } // d. If score > bestScore, then\n\n    if (score > bestScore) {\n      // i. Let bestScore be score.\n      bestScore = score; // ii. Let bestFormat be format.\n\n      bestFormat = format;\n    } // e. Increase i by 1.\n\n\n    i++;\n  } // 13. Return bestFormat.\n\n\n  return bestFormat;\n}\n/* 12.2.3 */\n\n\ninternals.DateTimeFormat = {\n  '[[availableLocales]]': [],\n  '[[relevantExtensionKeys]]': ['ca', 'nu'],\n  '[[localeData]]': {}\n};\n/**\n * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n * following steps are taken:\n */\n\n/* 12.2.2 */\n\ndefineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n  configurable: true,\n  writable: true,\n  value: fnBind.call(function (locales) {\n    // Bound functions only have the `this` value altered if being used as a constructor,\n    // this lets us imitate a native function that has no constructor\n    if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor'); // Create an object whose props can be used to restore the values of RegExp props\n\n    var regexpRestore = createRegExpRestore(),\n        // 1. If options is not provided, then let options be undefined.\n    options = arguments[1],\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n    //    property of the standard built-in object that is the initial value of\n    //    Intl.NumberFormat.\n    availableLocales = this['[[availableLocales]]'],\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    requestedLocales = CanonicalizeLocaleList(locales); // Restore the RegExp properties\n\n    regexpRestore(); // 4. Return the result of calling the SupportedLocales abstract operation\n    //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n    //    and options.\n\n    return SupportedLocales(availableLocales, requestedLocales, options);\n  }, internals.NumberFormat)\n});\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * DateTimeFormat object.\n */\n\n/* 12.3.2 */\n\ndefineProperty(Intl.DateTimeFormat.prototype, 'format', {\n  configurable: true,\n  get: GetFormatDateTime\n});\n\nfunction GetFormatDateTime() {\n  var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this); // Satisfy test 12.3_b\n\n  if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.'); // The value of the [[Get]] attribute is a function that takes the following\n  // steps:\n  // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n  //    is undefined, then:\n\n  if (internal['[[boundFormat]]'] === undefined) {\n    // a. Let F be a Function object, with internal properties set as\n    //    specified for built-in functions in ES5, 15, or successor, and the\n    //    length property set to 0, that takes the argument date and\n    //    performs the following steps:\n    var F = function F() {\n      var date = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0]; //   i. If date is not provided or is undefined, then let x be the\n      //      result as if by the expression Date.now() where Date.now is\n      //      the standard built-in function defined in ES5, 15.9.4.4.\n      //  ii. Else let x be ToNumber(date).\n      // iii. Return the result of calling the FormatDateTime abstract\n      //      operation (defined below) with arguments this and x.\n\n      var x = date === undefined ? Date.now() : toNumber(date);\n      return FormatDateTime(this, x);\n    }; // b. Let bind be the standard built-in function object defined in ES5,\n    //    15.3.4.5.\n    // c. Let bf be the result of calling the [[Call]] internal method of\n    //    bind with F as the this value and an argument list containing\n    //    the single item this.\n\n\n    var bf = fnBind.call(F, this); // d. Set the [[boundFormat]] internal property of this NumberFormat\n    //    object to bf.\n\n    internal['[[boundFormat]]'] = bf;\n  } // Return the value of the [[boundFormat]] internal property of this\n  // NumberFormat object.\n\n\n  return internal['[[boundFormat]]'];\n}\n\nfunction formatToParts$1() {\n  var date = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n  var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n  if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.DateTimeFormat object.');\n  var x = date === undefined ? Date.now() : toNumber(date);\n  return FormatToPartsDateTime(this, x);\n}\n\nObject.defineProperty(Intl.DateTimeFormat.prototype, 'formatToParts', {\n  enumerable: false,\n  writable: true,\n  configurable: true,\n  value: formatToParts$1\n});\n\nfunction CreateDateTimeParts(dateTimeFormat, x) {\n  // 1. If x is not a finite Number, then throw a RangeError exception.\n  if (!isFinite(x)) throw new RangeError('Invalid valid date passed to format');\n\n  var internal = dateTimeFormat.__getInternalProperties(secret); // Creating restore point for properties on the RegExp object... please wait\n\n  /* let regexpRestore = */\n\n\n  createRegExpRestore(); // ###TODO: review this\n  // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n\n  var locale = internal['[[locale]]']; // 3. Let nf be the result of creating a new NumberFormat object as if by the\n  // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n  // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n\n  var nf = new Intl.NumberFormat([locale], {\n    useGrouping: false\n  }); // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n  // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n  // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n  // 11.1.3.\n\n  var nf2 = new Intl.NumberFormat([locale], {\n    minimumIntegerDigits: 2,\n    useGrouping: false\n  }); // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n  // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n  // and the value of the [[timeZone]] internal property of dateTimeFormat.\n\n  var tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']); // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n\n  var pattern = internal['[[pattern]]']; // 7.\n\n  var result = new List(); // 8.\n\n  var index = 0; // 9.\n\n  var beginIndex = pattern.indexOf('{'); // 10.\n\n  var endIndex = 0; // Need the locale minus any extensions\n\n  var dataLocale = internal['[[dataLocale]]']; // Need the calendar data from CLDR\n\n  var localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars;\n  var ca = internal['[[calendar]]']; // 11.\n\n  while (beginIndex !== -1) {\n    var fv = void 0; // a.\n\n    endIndex = pattern.indexOf('}', beginIndex); // b.\n\n    if (endIndex === -1) {\n      throw new Error('Unclosed pattern');\n    } // c.\n\n\n    if (beginIndex > index) {\n      arrPush.call(result, {\n        type: 'literal',\n        value: pattern.substring(index, beginIndex)\n      });\n    } // d.\n\n\n    var p = pattern.substring(beginIndex + 1, endIndex); // e.\n\n    if (dateTimeComponents.hasOwnProperty(p)) {\n      //   i. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n      var f = internal['[[' + p + ']]']; //  ii. Let v be the value of tm.[[<p>]].\n\n      var v = tm['[[' + p + ']]']; // iii. If p is \"year\" and v ≤ 0, then let v be 1 - v.\n\n      if (p === 'year' && v <= 0) {\n        v = 1 - v;\n      } //  iv. If p is \"month\", then increase v by 1.\n      else if (p === 'month') {\n          v++;\n        } //   v. If p is \"hour\" and the value of the [[hour12]] internal property of\n        //      dateTimeFormat is true, then\n        else if (p === 'hour' && internal['[[hour12]]'] === true) {\n            // 1. Let v be v modulo 12.\n            v = v % 12; // 2. If v is 0 and the value of the [[hourNo0]] internal property of\n            //    dateTimeFormat is true, then let v be 12.\n\n            if (v === 0 && internal['[[hourNo0]]'] === true) {\n              v = 12;\n            }\n          } //  vi. If f is \"numeric\", then\n\n\n      if (f === 'numeric') {\n        // 1. Let fv be the result of calling the FormatNumber abstract operation\n        //    (defined in 11.3.2) with arguments nf and v.\n        fv = FormatNumber(nf, v);\n      } // vii. Else if f is \"2-digit\", then\n      else if (f === '2-digit') {\n          // 1. Let fv be the result of calling the FormatNumber abstract operation\n          //    with arguments nf2 and v.\n          fv = FormatNumber(nf2, v); // 2. If the length of fv is greater than 2, let fv be the substring of fv\n          //    containing the last two characters.\n\n          if (fv.length > 2) {\n            fv = fv.slice(-2);\n          }\n        } // viii. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n        //     value representing f in the desired form; the String value depends upon\n        //     the implementation and the effective locale and calendar of\n        //     dateTimeFormat. If p is \"month\", then the String value may also depend\n        //     on whether dateTimeFormat has a [[day]] internal property. If p is\n        //     \"timeZoneName\", then the String value may also depend on the value of\n        //     the [[inDST]] field of tm.\n        else if (f in dateWidths) {\n            switch (p) {\n              case 'month':\n                fv = resolveDateString(localeData, ca, 'months', f, tm['[[' + p + ']]']);\n                break;\n\n              case 'weekday':\n                try {\n                  fv = resolveDateString(localeData, ca, 'days', f, tm['[[' + p + ']]']); // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n                } catch (e) {\n                  throw new Error('Could not find weekday data for locale ' + locale);\n                }\n\n                break;\n\n              case 'timeZoneName':\n                fv = ''; // ###TODO\n\n                break;\n\n              case 'era':\n                try {\n                  fv = resolveDateString(localeData, ca, 'eras', f, tm['[[' + p + ']]']);\n                } catch (e) {\n                  throw new Error('Could not find era data for locale ' + locale);\n                }\n\n                break;\n\n              default:\n                fv = tm['[[' + p + ']]'];\n            }\n          } // ix\n\n\n      arrPush.call(result, {\n        type: p,\n        value: fv\n      }); // f.\n    } else if (p === 'ampm') {\n      // i.\n      var _v = tm['[[hour]]']; // ii./iii.\n\n      fv = resolveDateString(localeData, ca, 'dayPeriods', _v > 11 ? 'pm' : 'am', null); // iv.\n\n      arrPush.call(result, {\n        type: 'dayPeriod',\n        value: fv\n      }); // g.\n    } else {\n      arrPush.call(result, {\n        type: 'literal',\n        value: pattern.substring(beginIndex, endIndex + 1)\n      });\n    } // h.\n\n\n    index = endIndex + 1; // i.\n\n    beginIndex = pattern.indexOf('{', index);\n  } // 12.\n\n\n  if (endIndex < pattern.length - 1) {\n    arrPush.call(result, {\n      type: 'literal',\n      value: pattern.substr(endIndex + 1)\n    });\n  } // 13.\n\n\n  return result;\n}\n/**\n * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n * value), it returns a String value representing x (interpreted as a time value as\n * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n * options of dateTimeFormat.\n */\n\n\nfunction FormatDateTime(dateTimeFormat, x) {\n  var parts = CreateDateTimeParts(dateTimeFormat, x);\n  var result = '';\n\n  for (var i = 0; parts.length > i; i++) {\n    var part = parts[i];\n    result += part.value;\n  }\n\n  return result;\n}\n\nfunction FormatToPartsDateTime(dateTimeFormat, x) {\n  var parts = CreateDateTimeParts(dateTimeFormat, x);\n  var result = [];\n\n  for (var i = 0; parts.length > i; i++) {\n    var part = parts[i];\n    result.push({\n      type: part.type,\n      value: part.value\n    });\n  }\n\n  return result;\n}\n/**\n * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n * timeZone, the following steps are taken:\n */\n\n\nfunction ToLocalTime(date, calendar, timeZone) {\n  // 1. Apply calendrical calculations on date for the given calendar and time zone to\n  //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n  //    The calculations should use best available information about the specified\n  //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n  //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n  //    bound by the restrictions on the use of best available information on time zones\n  //    for local time zone adjustment and daylight saving time adjustment imposed by\n  //    ES5, 15.9.1.7 and 15.9.1.8.\n  // ###TODO###\n  var d = new Date(date),\n      m = 'get' + (timeZone || ''); // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n  //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n  //    calculated value.\n\n  return new Record({\n    '[[weekday]]': d[m + 'Day'](),\n    '[[era]]': +(d[m + 'FullYear']() >= 0),\n    '[[year]]': d[m + 'FullYear'](),\n    '[[month]]': d[m + 'Month'](),\n    '[[day]]': d[m + 'Date'](),\n    '[[hour]]': d[m + 'Hours'](),\n    '[[minute]]': d[m + 'Minutes'](),\n    '[[second]]': d[m + 'Seconds'](),\n    '[[inDST]]': false // ###TODO###\n\n  });\n}\n/**\n * The function returns a new object whose properties and attributes are set as if\n * constructed by an object literal assigning to each of the following properties the\n * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n * properties are not present are not assigned.\n */\n\n/* 12.3.3 */\n\n\ndefineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n  writable: true,\n  configurable: true,\n  value: function value() {\n    var prop = void 0,\n        descs = new Record(),\n        props = ['locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'],\n        internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this); // Satisfy test 12.3_b\n\n    if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\n    for (var i = 0, max = props.length; i < max; i++) {\n      if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = {\n        value: internal[prop],\n        writable: true,\n        configurable: true,\n        enumerable: true\n      };\n    }\n\n    return objCreate({}, descs);\n  }\n});\nvar ls = Intl.__localeSensitiveProtos = {\n  Number: {},\n  Date: {}\n};\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n\n/* 13.2.1 */\n\nls.Number.toLocaleString = function () {\n  // Satisfy test 13.2.1_1\n  if (Object.prototype.toString.call(this) !== '[object Number]') throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()'); // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n  // 2. If locales is not provided, then let locales be undefined.\n  // 3. If options is not provided, then let options be undefined.\n  // 4. Let numberFormat be the result of creating a new object as if by the\n  //    expression new Intl.NumberFormat(locales, options) where\n  //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n  // 5. Return the result of calling the FormatNumber abstract operation\n  //    (defined in 11.3.2) with arguments numberFormat and x.\n\n  return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n};\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n\n/* 13.3.1 */\n\n\nls.Date.toLocaleString = function () {\n  // Satisfy test 13.3.0_1\n  if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()'); // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\n  var x = +this; // 2. If x is NaN, then return \"Invalid Date\".\n\n  if (isNaN(x)) return 'Invalid Date'; // 3. If locales is not provided, then let locales be undefined.\n\n  var locales = arguments[0]; // 4. If options is not provided, then let options be undefined.\n\n  var options = arguments[1]; // 5. Let options be the result of calling the ToDateTimeOptions abstract\n  //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n\n  options = ToDateTimeOptions(options, 'any', 'all'); // 6. Let dateTimeFormat be the result of creating a new object as if by the\n  //    expression new Intl.DateTimeFormat(locales, options) where\n  //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\n  var dateTimeFormat = new DateTimeFormatConstructor(locales, options); // 7. Return the result of calling the FormatDateTime abstract operation (defined\n  //    in 12.3.2) with arguments dateTimeFormat and x.\n\n  return FormatDateTime(dateTimeFormat, x);\n};\n/**\n * When the toLocaleDateString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n\n/* 13.3.2 */\n\n\nls.Date.toLocaleDateString = function () {\n  // Satisfy test 13.3.0_1\n  if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()'); // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\n  var x = +this; // 2. If x is NaN, then return \"Invalid Date\".\n\n  if (isNaN(x)) return 'Invalid Date'; // 3. If locales is not provided, then let locales be undefined.\n\n  var locales = arguments[0],\n      // 4. If options is not provided, then let options be undefined.\n  options = arguments[1]; // 5. Let options be the result of calling the ToDateTimeOptions abstract\n  //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n\n  options = ToDateTimeOptions(options, 'date', 'date'); // 6. Let dateTimeFormat be the result of creating a new object as if by the\n  //    expression new Intl.DateTimeFormat(locales, options) where\n  //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\n  var dateTimeFormat = new DateTimeFormatConstructor(locales, options); // 7. Return the result of calling the FormatDateTime abstract operation (defined\n  //    in 12.3.2) with arguments dateTimeFormat and x.\n\n  return FormatDateTime(dateTimeFormat, x);\n};\n/**\n * When the toLocaleTimeString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n\n/* 13.3.3 */\n\n\nls.Date.toLocaleTimeString = function () {\n  // Satisfy test 13.3.0_1\n  if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()'); // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\n  var x = +this; // 2. If x is NaN, then return \"Invalid Date\".\n\n  if (isNaN(x)) return 'Invalid Date'; // 3. If locales is not provided, then let locales be undefined.\n\n  var locales = arguments[0]; // 4. If options is not provided, then let options be undefined.\n\n  var options = arguments[1]; // 5. Let options be the result of calling the ToDateTimeOptions abstract\n  //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n\n  options = ToDateTimeOptions(options, 'time', 'time'); // 6. Let dateTimeFormat be the result of creating a new object as if by the\n  //    expression new Intl.DateTimeFormat(locales, options) where\n  //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\n  var dateTimeFormat = new DateTimeFormatConstructor(locales, options); // 7. Return the result of calling the FormatDateTime abstract operation (defined\n  //    in 12.3.2) with arguments dateTimeFormat and x.\n\n  return FormatDateTime(dateTimeFormat, x);\n};\n\ndefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n  writable: true,\n  configurable: true,\n  value: function value() {\n    defineProperty(Number.prototype, 'toLocaleString', {\n      writable: true,\n      configurable: true,\n      value: ls.Number.toLocaleString\n    }); // Need this here for IE 8, to avoid the _DontEnum_ bug\n\n    defineProperty(Date.prototype, 'toLocaleString', {\n      writable: true,\n      configurable: true,\n      value: ls.Date.toLocaleString\n    });\n\n    for (var k in ls.Date) {\n      if (hop.call(ls.Date, k)) defineProperty(Date.prototype, k, {\n        writable: true,\n        configurable: true,\n        value: ls.Date[k]\n      });\n    }\n  }\n});\n/**\n * Can't really ship a single script with data for hundreds of locales, so we provide\n * this __addLocaleData method as a means for the developer to add the data on an\n * as-needed basis\n */\n\ndefineProperty(Intl, '__addLocaleData', {\n  value: function value(data) {\n    if (!IsStructurallyValidLanguageTag(data.locale)) throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n    addLocaleData(data, data.locale);\n  }\n});\n\nfunction addLocaleData(data, tag) {\n  // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n  if (!data.number) throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n  var locale = void 0,\n      locales = [tag],\n      parts = tag.split('-'); // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n\n  if (parts.length > 2 && parts[1].length === 4) arrPush.call(locales, parts[0] + '-' + parts[2]);\n\n  while (locale = arrShift.call(locales)) {\n    // Add to NumberFormat internal properties as per 11.2.3\n    arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n    internals.NumberFormat['[[localeData]]'][locale] = data.number; // ...and DateTimeFormat internal properties as per 12.2.3\n\n    if (data.date) {\n      data.date.nu = data.number.nu;\n      arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n      internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n    }\n  } // If this is the first set of locale data added, make it the default\n\n\n  if (defaultLocale === undefined) setDefaultLocale(tag);\n}\n\ndefineProperty(Intl, '__disableRegExpRestore', {\n  value: function value() {\n    internals.disableRegExpRestore = true;\n  }\n});\nmodule.exports = Intl;","map":{"version":3,"sources":["C:/Users/user/Downloads/reactjanpanproject1 - 复件(2)/reactjanpanproject1/node_modules/intl/lib/core.js"],"names":["_typeof","Symbol","iterator","obj","constructor","jsx","REACT_ELEMENT_TYPE","for","createRawReactElement","type","props","key","children","defaultProps","childrenLength","arguments","length","propName","childArray","Array","i","$$typeof","undefined","ref","_owner","asyncToGenerator","fn","gen","apply","Promise","resolve","reject","step","arg","info","value","error","done","then","err","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","descriptor","enumerable","configurable","writable","Object","defineProperty","protoProps","staticProps","prototype","defineEnumerableProperties","descs","desc","defaults","keys","getOwnPropertyNames","getOwnPropertyDescriptor","defineProperty$1","_extends","assign","source","hasOwnProperty","call","get","object","property","receiver","Function","parent","getPrototypeOf","getter","inherits","subClass","superClass","create","setPrototypeOf","__proto__","_instanceof","left","right","hasInstance","interopRequireDefault","__esModule","default","interopRequireWildcard","newObj","newArrowCheck","innerThis","boundThis","objectDestructuringEmpty","objectWithoutProperties","indexOf","possibleConstructorReturn","self","ReferenceError","selfGlobal","global","set","setter","slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_i","_s","next","push","isArray","slicedToArrayLoose","_iterator","_step","taggedTemplateLiteral","strings","raw","freeze","taggedTemplateLiteralLoose","temporalRef","val","name","undef","temporalUndefined","toArray","from","toConsumableArray","arr2","babelHelpers$1","typeof","extends","instanceof","realDefineProp","sentinel","a","e","es3","__defineGetter__","hop","arrIndexOf","search","t","max","objCreate","proto","F","k","arrSlice","slice","arrConcat","concat","arrPush","arrJoin","join","arrShift","shift","fnBind","bind","thisObj","args","internals","secret","Math","random","log10Floor","n","log10","floor","x","round","log","LOG10E","Number","Record","List","createRegExpRestore","disableRegExpRestore","regExpCache","lastMatch","RegExp","leftContext","multiline","input","has","esc","lm","replace","reg","m","exprStr","match","expr","lastIndex","exec","toObject","toNumber","toInteger","number","isNaN","Infinity","abs","toLength","len","pow","min","getInternalProperties","__getInternalProperties","extlang","language","script","region","variant","singleton","extension","privateuse","irregular","regular","grandfathered","langtag","expBCP47Syntax","expVariantDupes","expSingletonDupes","expExtSequences","defaultLocale","setDefaultLocale","locale","redundantTags","tags","subtags","BU","DD","FX","TP","YD","ZR","heploc","iw","ji","jw","mo","ayx","bjd","ccq","cjr","cka","cmk","drh","drw","gav","hrr","ibi","kgh","lcq","mst","myt","sca","tie","tkk","tlw","tnf","ybd","yma","extLang","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","aed","aen","afb","afg","ajp","apc","apd","arb","arq","ars","ary","arz","ase","asf","asp","asq","asw","auz","avl","ayh","ayl","ayn","ayp","bbz","bfi","bfk","bjn","bog","bqn","bqy","btj","bve","bvl","bvu","bzs","cdo","cds","cjy","cmn","coa","cpx","csc","csd","cse","csf","csg","csl","csn","csq","csr","czh","czo","doq","dse","dsl","dup","ecs","esl","esn","eso","eth","fcs","fse","fsl","fss","gan","gds","gom","gse","gsg","gsm","gss","gus","hab","haf","hak","hds","hji","hks","hos","hps","hsh","hsl","hsn","icl","ils","inl","ins","ise","isg","isr","jak","jax","jcs","jhs","jls","jos","jsl","jus","kgi","knn","kvb","kvk","kvr","kxd","lbs","lce","lcf","liw","lls","lsg","lsl","lso","lsp","lst","lsy","ltg","lvs","lzh","mdl","meo","mfa","mfb","mfs","mnp","mqg","mre","msd","msi","msr","mui","mzc","mzg","mzy","nan","nbs","ncs","nsi","nsl","nsp","nsr","nzs","okl","orn","ors","pel","pga","pks","prl","prz","psc","psd","pse","psg","psl","pso","psp","psr","pys","rms","rsi","rsl","sdl","sfb","sfs","sgg","sgx","shu","slf","sls","sqk","sqs","ssh","ssp","ssr","svk","swc","swh","swl","syy","tmw","tse","tsm","tsq","tss","tsy","tza","ugn","ugy","ukl","uks","urk","uzn","uzs","vgt","vkk","vkt","vsi","vsl","vsv","wuu","xki","xml","xmm","xms","yds","ysl","yue","zib","zlm","zmi","zsl","zsm","toLatinUpperCase","str","ch","charAt","toUpperCase","IsStructurallyValidLanguageTag","test","CanonicalizeLanguageTag","parts","toLowerCase","split","sort","_max","DefaultLocale","expCurrencyCode","IsWellFormedCurrencyCode","currency","c","String","normalized","expUnicodeExSeq","CanonicalizeLocaleList","locales","seen","O","Pk","kPresent","kValue","tag","RangeError","BestAvailableLocale","availableLocales","candidate","pos","lastIndexOf","substring","LookupMatcher","requestedLocales","availableLocale","noExtensionsLocale","result","extensionIndex","BestFitMatcher","ResolveLocale","options","relevantExtensionKeys","localeData","matcher","r","foundLocale","extensionSubtags","extensionSubtagsLength","supportedExtension","foundLocaleData","keyLocaleData","supportedExtensionAddition","keyPos","requestedValue","valuePos","_valuePos","optionsValue","privateIndex","preExtension","postExtension","LookupSupportedLocales","subset","subsetArray","BestFitSupportedLocales","SupportedLocales","localeMatcher","P","GetOption","values","fallback","Boolean","GetNumberOption","minimum","maximum","Intl","getCanonicalLocales","ll","currencyMinorUnits","BHD","BYR","XOF","BIF","XAF","CLF","CLP","KMF","DJF","XPF","GNF","ISK","IQD","JPY","JOD","KRW","KWD","LYD","OMR","PYG","RWF","TND","UGX","UYI","VUV","VND","NumberFormatConstructor","NumberFormat","InitializeNumberFormat","numberFormat","internal","regexpRestore","opt","dataLocale","s","cDigits","CurrencyDigits","cd","mnid","mnfdDefault","mnfd","mxfdDefault","mxfd","mnsd","minimumSignificantDigits","mxsd","maximumSignificantDigits","g","dataLocaleData","patterns","stylePatterns","positivePattern","negativePattern","format","GetFormatNumber","FormatNumber","bf","formatToParts","FormatNumberToParts","PartitionNumberPattern","part","nums","data","ild","symbols","latn","pattern","beginIndex","endIndex","nextIndex","Error","literal","p","isFinite","infinity","_n2","ToRawPrecision","ToRawFixed","numSys","digits","digit","integer","fraction","decimalSepIndex","groupSepSymbol","group","groups","pgSize","primaryGroupSize","sgSize","secondaryGroupSize","end","idx","start","integerGroup","decimalSepSymbol","decimal","plusSignSymbol","plusSign","minusSignSymbol","minusSign","percentSignSymbol","percentSign","currencies","_literal","_literal2","minPrecision","maxPrecision","f","exp","LN10","cut","minInteger","minFraction","maxFraction","toFixed","int","z","b","_z","arab","arabext","bali","beng","deva","fullwide","gujr","guru","hanidec","khmr","knda","laoo","limb","mlym","mong","mymr","orya","tamldec","telu","thai","tibt","prop","expDTComponents","expPatternTrimmer","unwantedDTCs","dtKeys","tmKeys","isDateFormatOnly","isTimeFormatOnly","joinDateAndTimeFormats","dateFormatObj","timeFormatObj","o","_","j","computeFinalPatterns","formatObj","pattern12","extendedPattern","$0","expDTComponentsMeta","era","year","quarter","month","week","day","weekday","hour12","hour","minute","second","timeZoneName","createDateTimeFormat","skeleton","originalPattern","createDateTimeFormats","formats","availableFormats","timeFormats","dateFormats","computed","timeRelatedFormats","dateRelatedFormats","full","long","medium","short","validSyntheticProps","numeric","narrow","generateSyntheticFormat","propValue","_ref2","dateWidths","resolveDateString","ca","component","width","gregory","alts","resolved","DateTimeFormatConstructor","DateTimeFormat","InitializeDateTimeFormat","dateTimeFormat","ToDateTimeOptions","tz","timeZone","dateTimeComponents","bestFormat","ToDateTimeFormats","BasicFormatMatcher","_hr","BestFitFormatMatcher","_prop","hr12","hourNo0","GetFormatDateTime","toString","required","opt2","needDefaults","removalPenalty","additionPenalty","longLessPenalty","longMorePenalty","shortLessPenalty","shortMorePenalty","bestScore","score","optionsProp","formatProp","optionsPropIndex","formatPropIndex","delta","optionsPropNames","_bestFormat","patternPenalty","hour12Penalty","_property","patternProp","date","Date","now","FormatDateTime","formatToParts$1","FormatToPartsDateTime","CreateDateTimeParts","nf","useGrouping","nf2","minimumIntegerDigits","tm","ToLocalTime","index","calendars","fv","v","_v","substr","calendar","d","ls","__localeSensitiveProtos","toLocaleString","toLocaleDateString","toLocaleTimeString","addLocaleData","nu","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\n\nvar jsx = function () {\n  var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  return function createRawReactElement(type, props, key, children) {\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {};\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  };\n}();\n\nvar asyncToGenerator = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            return step(\"next\", value);\n          }, function (err) {\n            return step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineEnumerableProperties = function (obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  return obj;\n};\n\nvar defaults = function (obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n};\n\nvar defineProperty$1 = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar _instanceof = function (left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n};\n\nvar interopRequireDefault = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n};\n\nvar interopRequireWildcard = function (obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n};\n\nvar newArrowCheck = function (innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n};\n\nvar objectDestructuringEmpty = function (obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar selfGlobal = typeof global === \"undefined\" ? self : global;\n\nvar set = function set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar slicedToArrayLoose = function (arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n};\n\nvar taggedTemplateLiteral = function (strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n};\n\nvar taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\nvar temporalRef = function (val, name, undef) {\n  if (val === undef) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n};\n\nvar temporalUndefined = {};\n\nvar toArray = function (arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n\n\nvar babelHelpers$1 = Object.freeze({\n  jsx: jsx,\n  asyncToGenerator: asyncToGenerator,\n  classCallCheck: classCallCheck,\n  createClass: createClass,\n  defineEnumerableProperties: defineEnumerableProperties,\n  defaults: defaults,\n  defineProperty: defineProperty$1,\n  get: get,\n  inherits: inherits,\n  interopRequireDefault: interopRequireDefault,\n  interopRequireWildcard: interopRequireWildcard,\n  newArrowCheck: newArrowCheck,\n  objectDestructuringEmpty: objectDestructuringEmpty,\n  objectWithoutProperties: objectWithoutProperties,\n  possibleConstructorReturn: possibleConstructorReturn,\n  selfGlobal: selfGlobal,\n  set: set,\n  slicedToArray: slicedToArray,\n  slicedToArrayLoose: slicedToArrayLoose,\n  taggedTemplateLiteral: taggedTemplateLiteral,\n  taggedTemplateLiteralLoose: taggedTemplateLiteralLoose,\n  temporalRef: temporalRef,\n  temporalUndefined: temporalUndefined,\n  toArray: toArray,\n  toConsumableArray: toConsumableArray,\n  typeof: _typeof,\n  extends: _extends,\n  instanceof: _instanceof\n});\n\nvar realDefineProp = function () {\n    var sentinel = function sentinel() {};\n    try {\n        Object.defineProperty(sentinel, 'a', {\n            get: function get() {\n                return 1;\n            }\n        });\n        Object.defineProperty(sentinel, 'prototype', { writable: false });\n        return sentinel.a === 1 && sentinel.prototype instanceof Object;\n    } catch (e) {\n        return false;\n    }\n}();\n\n// Need a workaround for getters in ES3\nvar es3 = !realDefineProp && !Object.prototype.__defineGetter__;\n\n// We use this a lot (and need it for proto-less objects)\nvar hop = Object.prototype.hasOwnProperty;\n\n// Naive defineProperty for compatibility\nvar defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n    if ('get' in desc && obj.__defineGetter__) obj.__defineGetter__(name, desc.get);else if (!hop.call(obj, name) || 'value' in desc) obj[name] = desc.value;\n};\n\n// Array.prototype.indexOf, as good as we need it to be\nvar arrIndexOf = Array.prototype.indexOf || function (search) {\n    /*jshint validthis:true */\n    var t = this;\n    if (!t.length) return -1;\n\n    for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n        if (t[i] === search) return i;\n    }\n\n    return -1;\n};\n\n// Create an object with the specified prototype (2nd arg required for Record)\nvar objCreate = Object.create || function (proto, props) {\n    var obj = void 0;\n\n    function F() {}\n    F.prototype = proto;\n    obj = new F();\n\n    for (var k in props) {\n        if (hop.call(props, k)) defineProperty(obj, k, props[k]);\n    }\n\n    return obj;\n};\n\n// Snapshot some (hopefully still) native built-ins\nvar arrSlice = Array.prototype.slice;\nvar arrConcat = Array.prototype.concat;\nvar arrPush = Array.prototype.push;\nvar arrJoin = Array.prototype.join;\nvar arrShift = Array.prototype.shift;\n\n// Naive Function.prototype.bind for compatibility\nvar fnBind = Function.prototype.bind || function (thisObj) {\n    var fn = this,\n        args = arrSlice.call(arguments, 1);\n\n    // All our (presently) bound functions have either 1 or 0 arguments. By returning\n    // different function signatures, we can pass some tests in ES3 environments\n    if (fn.length === 1) {\n        return function () {\n            return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n        };\n    }\n    return function () {\n        return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n    };\n};\n\n// Object housing internal properties for constructors\nvar internals = objCreate(null);\n\n// Keep internal properties internal\nvar secret = Math.random();\n\n// Helper functions\n// ================\n\n/**\n * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n * causing issue #62.\n */\nfunction log10Floor(n) {\n    // ES6 provides the more accurate Math.log10\n    if (typeof Math.log10 === 'function') return Math.floor(Math.log10(n));\n\n    var x = Math.round(Math.log(n) * Math.LOG10E);\n    return x - (Number('1e' + x) > n);\n}\n\n/**\n * A map that doesn't contain Object in its prototype chain\n */\nfunction Record(obj) {\n    // Copy only own properties over unless this object is already a Record instance\n    for (var k in obj) {\n        if (obj instanceof Record || hop.call(obj, k)) defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\n    }\n}\nRecord.prototype = objCreate(null);\n\n/**\n * An ordered list\n */\nfunction List() {\n    defineProperty(this, 'length', { writable: true, value: 0 });\n\n    if (arguments.length) arrPush.apply(this, arrSlice.call(arguments));\n}\nList.prototype = objCreate(null);\n\n/**\n * Constructs a regular expression to restore tainted RegExp properties\n */\nfunction createRegExpRestore() {\n    if (internals.disableRegExpRestore) {\n        return function () {/* no-op */};\n    }\n\n    var regExpCache = {\n        lastMatch: RegExp.lastMatch || '',\n        leftContext: RegExp.leftContext,\n        multiline: RegExp.multiline,\n        input: RegExp.input\n    },\n        has = false;\n\n    // Create a snapshot of all the 'captured' properties\n    for (var i = 1; i <= 9; i++) {\n        has = (regExpCache['$' + i] = RegExp['$' + i]) || has;\n    }return function () {\n        // Now we've snapshotted some properties, escape the lastMatch string\n        var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n            lm = regExpCache.lastMatch.replace(esc, '\\\\$&'),\n            reg = new List();\n\n        // If any of the captured strings were non-empty, iterate over them all\n        if (has) {\n            for (var _i = 1; _i <= 9; _i++) {\n                var m = regExpCache['$' + _i];\n\n                // If it's empty, add an empty capturing group\n                if (!m) lm = '()' + lm;\n\n                // Else find the string in lm and escape & wrap it to capture it\n                else {\n                        m = m.replace(esc, '\\\\$&');\n                        lm = lm.replace(m, '(' + m + ')');\n                    }\n\n                // Push it to the reg and chop lm to make sure further groups come after\n                arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n                lm = lm.slice(lm.indexOf('(') + 1);\n            }\n        }\n\n        var exprStr = arrJoin.call(reg, '') + lm;\n\n        // Shorten the regex by replacing each part of the expression with a match\n        // for a string of that exact length.  This is safe for the type of\n        // expressions generated above, because the expression matches the whole\n        // match string, so we know each group and each segment between capturing\n        // groups can be matched by its length alone.\n        exprStr = exprStr.replace(/(\\\\\\(|\\\\\\)|[^()])+/g, function (match) {\n            return '[\\\\s\\\\S]{' + match.replace('\\\\', '').length + '}';\n        });\n\n        // Create the regular expression that will reconstruct the RegExp properties\n        var expr = new RegExp(exprStr, regExpCache.multiline ? 'gm' : 'g');\n\n        // Set the lastIndex of the generated expression to ensure that the match\n        // is found in the correct index.\n        expr.lastIndex = regExpCache.leftContext.length;\n\n        expr.exec(regExpCache.input);\n    };\n}\n\n/**\n * Mimics ES5's abstract ToObject() function\n */\nfunction toObject(arg) {\n    if (arg === null) throw new TypeError('Cannot convert null or undefined to object');\n\n    if ((typeof arg === 'undefined' ? 'undefined' : babelHelpers$1['typeof'](arg)) === 'object') return arg;\n    return Object(arg);\n}\n\nfunction toNumber(arg) {\n    if (typeof arg === 'number') return arg;\n    return Number(arg);\n}\n\nfunction toInteger(arg) {\n    var number = toNumber(arg);\n    if (isNaN(number)) return 0;\n    if (number === +0 || number === -0 || number === +Infinity || number === -Infinity) return number;\n    if (number < 0) return Math.floor(Math.abs(number)) * -1;\n    return Math.floor(Math.abs(number));\n}\n\nfunction toLength(arg) {\n    var len = toInteger(arg);\n    if (len <= 0) return 0;\n    if (len === Infinity) return Math.pow(2, 53) - 1;\n    return Math.min(len, Math.pow(2, 53) - 1);\n}\n\n/**\n * Returns \"internal\" properties for an object\n */\nfunction getInternalProperties(obj) {\n    if (hop.call(obj, '__getInternalProperties')) return obj.__getInternalProperties(secret);\n\n    return objCreate(null);\n}\n\n/**\n* Defines regular expressions for various operations related to the BCP 47 syntax,\n* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n*/\n\n// extlang       = 3ALPHA              ; selected ISO 639 codes\n//                 *2(\"-\" 3ALPHA)      ; permanently reserved\nvar extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}';\n\n// language      = 2*3ALPHA            ; shortest ISO 639 code\n//                 [\"-\" extlang]       ; sometimes followed by\n//                                     ; extended language subtags\n//               / 4ALPHA              ; or reserved for future use\n//               / 5*8ALPHA            ; or registered language subtag\nvar language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})';\n\n// script        = 4ALPHA              ; ISO 15924 code\nvar script = '[a-z]{4}';\n\n// region        = 2ALPHA              ; ISO 3166-1 code\n//               / 3DIGIT              ; UN M.49 code\nvar region = '(?:[a-z]{2}|\\\\d{3})';\n\n// variant       = 5*8alphanum         ; registered variants\n//               / (DIGIT 3alphanum)\nvar variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})';\n\n//                                     ; Single alphanumerics\n//                                     ; \"x\" reserved for private use\n// singleton     = DIGIT               ; 0 - 9\n//               / %x41-57             ; A - W\n//               / %x59-5A             ; Y - Z\n//               / %x61-77             ; a - w\n//               / %x79-7A             ; y - z\nvar singleton = '[0-9a-wy-z]';\n\n// extension     = singleton 1*(\"-\" (2*8alphanum))\nvar extension = singleton + '(?:-[a-z0-9]{2,8})+';\n\n// privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\nvar privateuse = 'x(?:-[a-z0-9]{1,8})+';\n\n// irregular     = \"en-GB-oed\"         ; irregular tags do not match\n//               / \"i-ami\"             ; the 'langtag' production and\n//               / \"i-bnn\"             ; would not otherwise be\n//               / \"i-default\"         ; considered 'well-formed'\n//               / \"i-enochian\"        ; These tags are all valid,\n//               / \"i-hak\"             ; but most are deprecated\n//               / \"i-klingon\"         ; in favor of more modern\n//               / \"i-lux\"             ; subtags or subtag\n//               / \"i-mingo\"           ; combination\n//               / \"i-navajo\"\n//               / \"i-pwn\"\n//               / \"i-tao\"\n//               / \"i-tay\"\n//               / \"i-tsu\"\n//               / \"sgn-BE-FR\"\n//               / \"sgn-BE-NL\"\n//               / \"sgn-CH-DE\"\nvar irregular = '(?:en-GB-oed' + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)' + '|sgn-(?:BE-FR|BE-NL|CH-DE))';\n\n// regular       = \"art-lojban\"        ; these tags match the 'langtag'\n//               / \"cel-gaulish\"       ; production, but their subtags\n//               / \"no-bok\"            ; are not extended language\n//               / \"no-nyn\"            ; or variant subtags: their meaning\n//               / \"zh-guoyu\"          ; is defined by their registration\n//               / \"zh-hakka\"          ; and all of these are deprecated\n//               / \"zh-min\"            ; in favor of a more modern\n//               / \"zh-min-nan\"        ; subtag or sequence of subtags\n//               / \"zh-xiang\"\nvar regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn' + '|zh-(?:guoyu|hakka|min|min-nan|xiang))';\n\n// grandfathered = irregular           ; non-redundant tags registered\n//               / regular             ; during the RFC 3066 era\nvar grandfathered = '(?:' + irregular + '|' + regular + ')';\n\n// langtag       = language\n//                 [\"-\" script]\n//                 [\"-\" region]\n//                 *(\"-\" variant)\n//                 *(\"-\" extension)\n//                 [\"-\" privateuse]\nvar langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-' + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\n\n// Language-Tag  = langtag             ; normal language tags\n//               / privateuse          ; private use tag\n//               / grandfathered       ; grandfathered tags\nvar expBCP47Syntax = RegExp('^(?:' + langtag + '|' + privateuse + '|' + grandfathered + ')$', 'i');\n\n// Match duplicate variants in a language tag\nvar expVariantDupes = RegExp('^(?!x).*?-(' + variant + ')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match duplicate singletons in a language tag (except in private use)\nvar expSingletonDupes = RegExp('^(?!x).*?-(' + singleton + ')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match all extension sequences\nvar expExtSequences = RegExp('-' + extension, 'ig');\n\n// Default locale is the first-added locale data for us\nvar defaultLocale = void 0;\nfunction setDefaultLocale(locale) {\n    defaultLocale = locale;\n}\n\n// IANA Subtag Registry redundant tag and subtag maps\nvar redundantTags = {\n    tags: {\n        \"art-lojban\": \"jbo\",\n        \"i-ami\": \"ami\",\n        \"i-bnn\": \"bnn\",\n        \"i-hak\": \"hak\",\n        \"i-klingon\": \"tlh\",\n        \"i-lux\": \"lb\",\n        \"i-navajo\": \"nv\",\n        \"i-pwn\": \"pwn\",\n        \"i-tao\": \"tao\",\n        \"i-tay\": \"tay\",\n        \"i-tsu\": \"tsu\",\n        \"no-bok\": \"nb\",\n        \"no-nyn\": \"nn\",\n        \"sgn-BE-FR\": \"sfb\",\n        \"sgn-BE-NL\": \"vgt\",\n        \"sgn-CH-DE\": \"sgg\",\n        \"zh-guoyu\": \"cmn\",\n        \"zh-hakka\": \"hak\",\n        \"zh-min-nan\": \"nan\",\n        \"zh-xiang\": \"hsn\",\n        \"sgn-BR\": \"bzs\",\n        \"sgn-CO\": \"csn\",\n        \"sgn-DE\": \"gsg\",\n        \"sgn-DK\": \"dsl\",\n        \"sgn-ES\": \"ssp\",\n        \"sgn-FR\": \"fsl\",\n        \"sgn-GB\": \"bfi\",\n        \"sgn-GR\": \"gss\",\n        \"sgn-IE\": \"isg\",\n        \"sgn-IT\": \"ise\",\n        \"sgn-JP\": \"jsl\",\n        \"sgn-MX\": \"mfs\",\n        \"sgn-NI\": \"ncs\",\n        \"sgn-NL\": \"dse\",\n        \"sgn-NO\": \"nsl\",\n        \"sgn-PT\": \"psr\",\n        \"sgn-SE\": \"swl\",\n        \"sgn-US\": \"ase\",\n        \"sgn-ZA\": \"sfs\",\n        \"zh-cmn\": \"cmn\",\n        \"zh-cmn-Hans\": \"cmn-Hans\",\n        \"zh-cmn-Hant\": \"cmn-Hant\",\n        \"zh-gan\": \"gan\",\n        \"zh-wuu\": \"wuu\",\n        \"zh-yue\": \"yue\"\n    },\n    subtags: {\n        BU: \"MM\",\n        DD: \"DE\",\n        FX: \"FR\",\n        TP: \"TL\",\n        YD: \"YE\",\n        ZR: \"CD\",\n        heploc: \"alalc97\",\n        'in': \"id\",\n        iw: \"he\",\n        ji: \"yi\",\n        jw: \"jv\",\n        mo: \"ro\",\n        ayx: \"nun\",\n        bjd: \"drl\",\n        ccq: \"rki\",\n        cjr: \"mom\",\n        cka: \"cmr\",\n        cmk: \"xch\",\n        drh: \"khk\",\n        drw: \"prs\",\n        gav: \"dev\",\n        hrr: \"jal\",\n        ibi: \"opa\",\n        kgh: \"kml\",\n        lcq: \"ppr\",\n        mst: \"mry\",\n        myt: \"mry\",\n        sca: \"hle\",\n        tie: \"ras\",\n        tkk: \"twm\",\n        tlw: \"weo\",\n        tnf: \"prs\",\n        ybd: \"rki\",\n        yma: \"lrr\"\n    },\n    extLang: {\n        aao: [\"aao\", \"ar\"],\n        abh: [\"abh\", \"ar\"],\n        abv: [\"abv\", \"ar\"],\n        acm: [\"acm\", \"ar\"],\n        acq: [\"acq\", \"ar\"],\n        acw: [\"acw\", \"ar\"],\n        acx: [\"acx\", \"ar\"],\n        acy: [\"acy\", \"ar\"],\n        adf: [\"adf\", \"ar\"],\n        ads: [\"ads\", \"sgn\"],\n        aeb: [\"aeb\", \"ar\"],\n        aec: [\"aec\", \"ar\"],\n        aed: [\"aed\", \"sgn\"],\n        aen: [\"aen\", \"sgn\"],\n        afb: [\"afb\", \"ar\"],\n        afg: [\"afg\", \"sgn\"],\n        ajp: [\"ajp\", \"ar\"],\n        apc: [\"apc\", \"ar\"],\n        apd: [\"apd\", \"ar\"],\n        arb: [\"arb\", \"ar\"],\n        arq: [\"arq\", \"ar\"],\n        ars: [\"ars\", \"ar\"],\n        ary: [\"ary\", \"ar\"],\n        arz: [\"arz\", \"ar\"],\n        ase: [\"ase\", \"sgn\"],\n        asf: [\"asf\", \"sgn\"],\n        asp: [\"asp\", \"sgn\"],\n        asq: [\"asq\", \"sgn\"],\n        asw: [\"asw\", \"sgn\"],\n        auz: [\"auz\", \"ar\"],\n        avl: [\"avl\", \"ar\"],\n        ayh: [\"ayh\", \"ar\"],\n        ayl: [\"ayl\", \"ar\"],\n        ayn: [\"ayn\", \"ar\"],\n        ayp: [\"ayp\", \"ar\"],\n        bbz: [\"bbz\", \"ar\"],\n        bfi: [\"bfi\", \"sgn\"],\n        bfk: [\"bfk\", \"sgn\"],\n        bjn: [\"bjn\", \"ms\"],\n        bog: [\"bog\", \"sgn\"],\n        bqn: [\"bqn\", \"sgn\"],\n        bqy: [\"bqy\", \"sgn\"],\n        btj: [\"btj\", \"ms\"],\n        bve: [\"bve\", \"ms\"],\n        bvl: [\"bvl\", \"sgn\"],\n        bvu: [\"bvu\", \"ms\"],\n        bzs: [\"bzs\", \"sgn\"],\n        cdo: [\"cdo\", \"zh\"],\n        cds: [\"cds\", \"sgn\"],\n        cjy: [\"cjy\", \"zh\"],\n        cmn: [\"cmn\", \"zh\"],\n        coa: [\"coa\", \"ms\"],\n        cpx: [\"cpx\", \"zh\"],\n        csc: [\"csc\", \"sgn\"],\n        csd: [\"csd\", \"sgn\"],\n        cse: [\"cse\", \"sgn\"],\n        csf: [\"csf\", \"sgn\"],\n        csg: [\"csg\", \"sgn\"],\n        csl: [\"csl\", \"sgn\"],\n        csn: [\"csn\", \"sgn\"],\n        csq: [\"csq\", \"sgn\"],\n        csr: [\"csr\", \"sgn\"],\n        czh: [\"czh\", \"zh\"],\n        czo: [\"czo\", \"zh\"],\n        doq: [\"doq\", \"sgn\"],\n        dse: [\"dse\", \"sgn\"],\n        dsl: [\"dsl\", \"sgn\"],\n        dup: [\"dup\", \"ms\"],\n        ecs: [\"ecs\", \"sgn\"],\n        esl: [\"esl\", \"sgn\"],\n        esn: [\"esn\", \"sgn\"],\n        eso: [\"eso\", \"sgn\"],\n        eth: [\"eth\", \"sgn\"],\n        fcs: [\"fcs\", \"sgn\"],\n        fse: [\"fse\", \"sgn\"],\n        fsl: [\"fsl\", \"sgn\"],\n        fss: [\"fss\", \"sgn\"],\n        gan: [\"gan\", \"zh\"],\n        gds: [\"gds\", \"sgn\"],\n        gom: [\"gom\", \"kok\"],\n        gse: [\"gse\", \"sgn\"],\n        gsg: [\"gsg\", \"sgn\"],\n        gsm: [\"gsm\", \"sgn\"],\n        gss: [\"gss\", \"sgn\"],\n        gus: [\"gus\", \"sgn\"],\n        hab: [\"hab\", \"sgn\"],\n        haf: [\"haf\", \"sgn\"],\n        hak: [\"hak\", \"zh\"],\n        hds: [\"hds\", \"sgn\"],\n        hji: [\"hji\", \"ms\"],\n        hks: [\"hks\", \"sgn\"],\n        hos: [\"hos\", \"sgn\"],\n        hps: [\"hps\", \"sgn\"],\n        hsh: [\"hsh\", \"sgn\"],\n        hsl: [\"hsl\", \"sgn\"],\n        hsn: [\"hsn\", \"zh\"],\n        icl: [\"icl\", \"sgn\"],\n        ils: [\"ils\", \"sgn\"],\n        inl: [\"inl\", \"sgn\"],\n        ins: [\"ins\", \"sgn\"],\n        ise: [\"ise\", \"sgn\"],\n        isg: [\"isg\", \"sgn\"],\n        isr: [\"isr\", \"sgn\"],\n        jak: [\"jak\", \"ms\"],\n        jax: [\"jax\", \"ms\"],\n        jcs: [\"jcs\", \"sgn\"],\n        jhs: [\"jhs\", \"sgn\"],\n        jls: [\"jls\", \"sgn\"],\n        jos: [\"jos\", \"sgn\"],\n        jsl: [\"jsl\", \"sgn\"],\n        jus: [\"jus\", \"sgn\"],\n        kgi: [\"kgi\", \"sgn\"],\n        knn: [\"knn\", \"kok\"],\n        kvb: [\"kvb\", \"ms\"],\n        kvk: [\"kvk\", \"sgn\"],\n        kvr: [\"kvr\", \"ms\"],\n        kxd: [\"kxd\", \"ms\"],\n        lbs: [\"lbs\", \"sgn\"],\n        lce: [\"lce\", \"ms\"],\n        lcf: [\"lcf\", \"ms\"],\n        liw: [\"liw\", \"ms\"],\n        lls: [\"lls\", \"sgn\"],\n        lsg: [\"lsg\", \"sgn\"],\n        lsl: [\"lsl\", \"sgn\"],\n        lso: [\"lso\", \"sgn\"],\n        lsp: [\"lsp\", \"sgn\"],\n        lst: [\"lst\", \"sgn\"],\n        lsy: [\"lsy\", \"sgn\"],\n        ltg: [\"ltg\", \"lv\"],\n        lvs: [\"lvs\", \"lv\"],\n        lzh: [\"lzh\", \"zh\"],\n        max: [\"max\", \"ms\"],\n        mdl: [\"mdl\", \"sgn\"],\n        meo: [\"meo\", \"ms\"],\n        mfa: [\"mfa\", \"ms\"],\n        mfb: [\"mfb\", \"ms\"],\n        mfs: [\"mfs\", \"sgn\"],\n        min: [\"min\", \"ms\"],\n        mnp: [\"mnp\", \"zh\"],\n        mqg: [\"mqg\", \"ms\"],\n        mre: [\"mre\", \"sgn\"],\n        msd: [\"msd\", \"sgn\"],\n        msi: [\"msi\", \"ms\"],\n        msr: [\"msr\", \"sgn\"],\n        mui: [\"mui\", \"ms\"],\n        mzc: [\"mzc\", \"sgn\"],\n        mzg: [\"mzg\", \"sgn\"],\n        mzy: [\"mzy\", \"sgn\"],\n        nan: [\"nan\", \"zh\"],\n        nbs: [\"nbs\", \"sgn\"],\n        ncs: [\"ncs\", \"sgn\"],\n        nsi: [\"nsi\", \"sgn\"],\n        nsl: [\"nsl\", \"sgn\"],\n        nsp: [\"nsp\", \"sgn\"],\n        nsr: [\"nsr\", \"sgn\"],\n        nzs: [\"nzs\", \"sgn\"],\n        okl: [\"okl\", \"sgn\"],\n        orn: [\"orn\", \"ms\"],\n        ors: [\"ors\", \"ms\"],\n        pel: [\"pel\", \"ms\"],\n        pga: [\"pga\", \"ar\"],\n        pks: [\"pks\", \"sgn\"],\n        prl: [\"prl\", \"sgn\"],\n        prz: [\"prz\", \"sgn\"],\n        psc: [\"psc\", \"sgn\"],\n        psd: [\"psd\", \"sgn\"],\n        pse: [\"pse\", \"ms\"],\n        psg: [\"psg\", \"sgn\"],\n        psl: [\"psl\", \"sgn\"],\n        pso: [\"pso\", \"sgn\"],\n        psp: [\"psp\", \"sgn\"],\n        psr: [\"psr\", \"sgn\"],\n        pys: [\"pys\", \"sgn\"],\n        rms: [\"rms\", \"sgn\"],\n        rsi: [\"rsi\", \"sgn\"],\n        rsl: [\"rsl\", \"sgn\"],\n        sdl: [\"sdl\", \"sgn\"],\n        sfb: [\"sfb\", \"sgn\"],\n        sfs: [\"sfs\", \"sgn\"],\n        sgg: [\"sgg\", \"sgn\"],\n        sgx: [\"sgx\", \"sgn\"],\n        shu: [\"shu\", \"ar\"],\n        slf: [\"slf\", \"sgn\"],\n        sls: [\"sls\", \"sgn\"],\n        sqk: [\"sqk\", \"sgn\"],\n        sqs: [\"sqs\", \"sgn\"],\n        ssh: [\"ssh\", \"ar\"],\n        ssp: [\"ssp\", \"sgn\"],\n        ssr: [\"ssr\", \"sgn\"],\n        svk: [\"svk\", \"sgn\"],\n        swc: [\"swc\", \"sw\"],\n        swh: [\"swh\", \"sw\"],\n        swl: [\"swl\", \"sgn\"],\n        syy: [\"syy\", \"sgn\"],\n        tmw: [\"tmw\", \"ms\"],\n        tse: [\"tse\", \"sgn\"],\n        tsm: [\"tsm\", \"sgn\"],\n        tsq: [\"tsq\", \"sgn\"],\n        tss: [\"tss\", \"sgn\"],\n        tsy: [\"tsy\", \"sgn\"],\n        tza: [\"tza\", \"sgn\"],\n        ugn: [\"ugn\", \"sgn\"],\n        ugy: [\"ugy\", \"sgn\"],\n        ukl: [\"ukl\", \"sgn\"],\n        uks: [\"uks\", \"sgn\"],\n        urk: [\"urk\", \"ms\"],\n        uzn: [\"uzn\", \"uz\"],\n        uzs: [\"uzs\", \"uz\"],\n        vgt: [\"vgt\", \"sgn\"],\n        vkk: [\"vkk\", \"ms\"],\n        vkt: [\"vkt\", \"ms\"],\n        vsi: [\"vsi\", \"sgn\"],\n        vsl: [\"vsl\", \"sgn\"],\n        vsv: [\"vsv\", \"sgn\"],\n        wuu: [\"wuu\", \"zh\"],\n        xki: [\"xki\", \"sgn\"],\n        xml: [\"xml\", \"sgn\"],\n        xmm: [\"xmm\", \"ms\"],\n        xms: [\"xms\", \"sgn\"],\n        yds: [\"yds\", \"sgn\"],\n        ysl: [\"ysl\", \"sgn\"],\n        yue: [\"yue\", \"zh\"],\n        zib: [\"zib\", \"sgn\"],\n        zlm: [\"zlm\", \"ms\"],\n        zmi: [\"zmi\", \"ms\"],\n        zsl: [\"zsl\", \"sgn\"],\n        zsm: [\"zsm\", \"ms\"]\n    }\n};\n\n/**\n * Convert only a-z to uppercase as per section 6.1 of the spec\n */\nfunction toLatinUpperCase(str) {\n    var i = str.length;\n\n    while (i--) {\n        var ch = str.charAt(i);\n\n        if (ch >= \"a\" && ch <= \"z\") str = str.slice(0, i) + ch.toUpperCase() + str.slice(i + 1);\n    }\n\n    return str;\n}\n\n/**\n * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n * argument (which must be a String value)\n *\n * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n *   2.1, or successor,\n * - does not include duplicate variant subtags, and\n * - does not include duplicate singleton subtags.\n *\n * The abstract operation returns true if locale can be generated from the ABNF\n * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n * contain duplicate variant or singleton subtags (other than as a private use\n * subtag). It returns false otherwise. Terminal value characters in the grammar are\n * interpreted as the Unicode equivalents of the ASCII octet values given.\n */\nfunction /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\n    // represents a well-formed BCP 47 language tag as specified in RFC 5646\n    if (!expBCP47Syntax.test(locale)) return false;\n\n    // does not include duplicate variant subtags, and\n    if (expVariantDupes.test(locale)) return false;\n\n    // does not include duplicate singleton subtags.\n    if (expSingletonDupes.test(locale)) return false;\n\n    return true;\n}\n\n/**\n * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n * regularized form of the locale argument (which must be a String value that is\n * a structurally valid BCP 47 language tag as verified by the\n * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n * into canonical form, and to regularize the case of the subtags, but does not\n * take the steps to bring a language tag into “extlang form” and to reorder\n * variant subtags.\n\n * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n * may include canonicalization rules for the extension subtag sequences they\n * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n * Implementations are allowed, but not required, to apply these additional rules.\n */\nfunction /* 6.2.3 */CanonicalizeLanguageTag(locale) {\n    var match = void 0,\n        parts = void 0;\n\n    // A language tag is in 'canonical form' when the tag is well-formed\n    // according to the rules in Sections 2.1 and 2.2\n\n    // Section 2.1 says all subtags use lowercase...\n    locale = locale.toLowerCase();\n\n    // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n    // appear at the start of the tag nor occur after singletons.  Such two-letter\n    // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n    // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n    parts = locale.split('-');\n    for (var i = 1, max = parts.length; i < max; i++) {\n        // Two-letter subtags are all uppercase\n        if (parts[i].length === 2) parts[i] = parts[i].toUpperCase();\n\n        // Four-letter subtags are titlecase\n        else if (parts[i].length === 4) parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\n\n            // Is it a singleton?\n            else if (parts[i].length === 1 && parts[i] !== 'x') break;\n    }\n    locale = arrJoin.call(parts, '-');\n\n    // The steps laid out in RFC 5646 section 4.5 are as follows:\n\n    // 1.  Extension sequences are ordered into case-insensitive ASCII order\n    //     by singleton subtag.\n    if ((match = locale.match(expExtSequences)) && match.length > 1) {\n        // The built-in sort() sorts by ASCII order, so use that\n        match.sort();\n\n        // Replace all extensions with the joined, sorted array\n        locale = locale.replace(RegExp('(?:' + expExtSequences.source + ')+', 'i'), arrJoin.call(match, ''));\n    }\n\n    // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n    //     Value', if there is one.\n    if (hop.call(redundantTags.tags, locale)) locale = redundantTags.tags[locale];\n\n    // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n    //     For extlangs, the original primary language subtag is also\n    //     replaced if there is a primary language subtag in the 'Preferred-\n    //     Value'.\n    parts = locale.split('-');\n\n    for (var _i = 1, _max = parts.length; _i < _max; _i++) {\n        if (hop.call(redundantTags.subtags, parts[_i])) parts[_i] = redundantTags.subtags[parts[_i]];else if (hop.call(redundantTags.extLang, parts[_i])) {\n            parts[_i] = redundantTags.extLang[parts[_i]][0];\n\n            // For extlang tags, the prefix needs to be removed if it is redundant\n            if (_i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n                parts = arrSlice.call(parts, _i++);\n                _max -= 1;\n            }\n        }\n    }\n\n    return arrJoin.call(parts, '-');\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the\n * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n * host environment’s current locale.\n */\nfunction /* 6.2.4 */DefaultLocale() {\n    return defaultLocale;\n}\n\n// Sect 6.3 Currency Codes\n// =======================\n\nvar expCurrencyCode = /^[A-Z]{3}$/;\n\n/**\n * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n * code. The following steps are taken:\n */\nfunction /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\n    // 1. Let `c` be ToString(currency)\n    var c = String(currency);\n\n    // 2. Let `normalized` be the result of mapping c to upper case as described\n    //    in 6.1.\n    var normalized = toLatinUpperCase(c);\n\n    // 3. If the string length of normalized is not 3, return false.\n    // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n    //    (U+0041 to U+005A), return false.\n    if (expCurrencyCode.test(normalized) === false) return false;\n\n    // 5. Return true\n    return true;\n}\n\nvar expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi; // See `extension` below\n\nfunction /* 9.2.1 */CanonicalizeLocaleList(locales) {\n    // The abstract operation CanonicalizeLocaleList takes the following steps:\n\n    // 1. If locales is undefined, then a. Return a new empty List\n    if (locales === undefined) return new List();\n\n    // 2. Let seen be a new empty List.\n    var seen = new List();\n\n    // 3. If locales is a String value, then\n    //    a. Let locales be a new array created as if by the expression new\n    //    Array(locales) where Array is the standard built-in constructor with\n    //    that name and locales is the value of locales.\n    locales = typeof locales === 'string' ? [locales] : locales;\n\n    // 4. Let O be ToObject(locales).\n    var O = toObject(locales);\n\n    // 5. Let lenValue be the result of calling the [[Get]] internal method of\n    //    O with the argument \"length\".\n    // 6. Let len be ToUint32(lenValue).\n    var len = toLength(O.length);\n\n    // 7. Let k be 0.\n    var k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n        // a. Let Pk be ToString(k).\n        var Pk = String(k);\n\n        // b. Let kPresent be the result of calling the [[HasProperty]] internal\n        //    method of O with argument Pk.\n        var kPresent = Pk in O;\n\n        // c. If kPresent is true, then\n        if (kPresent) {\n            // i. Let kValue be the result of calling the [[Get]] internal\n            //     method of O with argument Pk.\n            var kValue = O[Pk];\n\n            // ii. If the type of kValue is not String or Object, then throw a\n            //     TypeError exception.\n            if (kValue === null || typeof kValue !== 'string' && (typeof kValue === \"undefined\" ? \"undefined\" : babelHelpers$1[\"typeof\"](kValue)) !== 'object') throw new TypeError('String or Object type expected');\n\n            // iii. Let tag be ToString(kValue).\n            var tag = String(kValue);\n\n            // iv. If the result of calling the abstract operation\n            //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n            //     the argument, is false, then throw a RangeError exception.\n            if (!IsStructurallyValidLanguageTag(tag)) throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\n\n            // v. Let tag be the result of calling the abstract operation\n            //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n            //    argument.\n            tag = CanonicalizeLanguageTag(tag);\n\n            // vi. If tag is not an element of seen, then append tag as the last\n            //     element of seen.\n            if (arrIndexOf.call(seen, tag) === -1) arrPush.call(seen, tag);\n        }\n\n        // d. Increase k by 1.\n        k++;\n    }\n\n    // 9. Return seen.\n    return seen;\n}\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument\n * locale, which must be a String value with a structurally valid and\n * canonicalized BCP 47 language tag, against the locales in availableLocales and\n * returns either the longest non-empty prefix of locale that is an element of\n * availableLocales, or undefined if there is no such element. It uses the\n * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n */\nfunction /* 9.2.2 */BestAvailableLocale(availableLocales, locale) {\n    // 1. Let candidate be locale\n    var candidate = locale;\n\n    // 2. Repeat\n    while (candidate) {\n        // a. If availableLocales contains an element equal to candidate, then return\n        // candidate.\n        if (arrIndexOf.call(availableLocales, candidate) > -1) return candidate;\n\n        // b. Let pos be the character index of the last occurrence of \"-\"\n        // (U+002D) within candidate. If that character does not occur, return\n        // undefined.\n        var pos = candidate.lastIndexOf('-');\n\n        if (pos < 0) return;\n\n        // c. If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate,\n        //    then decrease pos by 2.\n        if (pos >= 2 && candidate.charAt(pos - 2) === '-') pos -= 2;\n\n        // d. Let candidate be the substring of candidate from position 0, inclusive,\n        //    to position pos, exclusive.\n        candidate = candidate.substring(0, pos);\n    }\n}\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The following steps are taken:\n */\nfunction /* 9.2.3 */LookupMatcher(availableLocales, requestedLocales) {\n    // 1. Let i be 0.\n    var i = 0;\n\n    // 2. Let len be the number of elements in requestedLocales.\n    var len = requestedLocales.length;\n\n    // 3. Let availableLocale be undefined.\n    var availableLocale = void 0;\n\n    var locale = void 0,\n        noExtensionsLocale = void 0;\n\n    // 4. Repeat while i < len and availableLocale is undefined:\n    while (i < len && !availableLocale) {\n        // a. Let locale be the element of requestedLocales at 0-origined list\n        //    position i.\n        locale = requestedLocales[i];\n\n        // b. Let noExtensionsLocale be the String value that is locale with all\n        //    Unicode locale extension sequences removed.\n        noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n\n        // c. Let availableLocale be the result of calling the\n        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n        //    arguments availableLocales and noExtensionsLocale.\n        availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. Increase i by 1.\n        i++;\n    }\n\n    // 5. Let result be a new Record.\n    var result = new Record();\n\n    // 6. If availableLocale is not undefined, then\n    if (availableLocale !== undefined) {\n        // a. Set result.[[locale]] to availableLocale.\n        result['[[locale]]'] = availableLocale;\n\n        // b. If locale and noExtensionsLocale are not the same String value, then\n        if (String(locale) !== String(noExtensionsLocale)) {\n            // i. Let extension be the String value consisting of the first\n            //    substring of locale that is a Unicode locale extension sequence.\n            var extension = locale.match(expUnicodeExSeq)[0];\n\n            // ii. Let extensionIndex be the character position of the initial\n            //     \"-\" of the first Unicode locale extension sequence within locale.\n            var extensionIndex = locale.indexOf('-u-');\n\n            // iii. Set result.[[extension]] to extension.\n            result['[[extension]]'] = extension;\n\n            // iv. Set result.[[extensionIndex]] to extensionIndex.\n            result['[[extensionIndex]]'] = extensionIndex;\n        }\n    }\n    // 7. Else\n    else\n        // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n        //    operation (defined in 6.2.4).\n        result['[[locale]]'] = DefaultLocale();\n\n    // 8. Return result\n    return result;\n}\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The algorithm is implementation dependent, but should produce results\n * that a typical user of the requested locales would perceive as at least as\n * good as those produced by the LookupMatcher abstract operation. Options\n * specified through Unicode locale extension sequences must be ignored by the\n * algorithm. Information about such subsequences is returned separately.\n * The abstract operation returns a record with a [[locale]] field, whose value\n * is the language tag of the selected locale, which must be an element of\n * availableLocales. If the language tag of the request locale that led to the\n * selected locale contained a Unicode locale extension sequence, then the\n * returned record also contains an [[extension]] field whose value is the first\n * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n * is the index of the first Unicode locale extension sequence within the request\n * locale language tag.\n */\nfunction /* 9.2.4 */BestFitMatcher(availableLocales, requestedLocales) {\n    return LookupMatcher(availableLocales, requestedLocales);\n}\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the\n * best available language to meet the request. availableLocales and\n * requestedLocales must be provided as List values, options as a Record.\n */\nfunction /* 9.2.5 */ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n    if (availableLocales.length === 0) {\n        throw new ReferenceError('No locale data has been provided for this object yet.');\n    }\n\n    // The following steps are taken:\n    // 1. Let matcher be the value of options.[[localeMatcher]].\n    var matcher = options['[[localeMatcher]]'];\n\n    var r = void 0;\n\n    // 2. If matcher is \"lookup\", then\n    if (matcher === 'lookup')\n        // a. Let r be the result of calling the LookupMatcher abstract operation\n        //    (defined in 9.2.3) with arguments availableLocales and\n        //    requestedLocales.\n        r = LookupMatcher(availableLocales, requestedLocales);\n\n        // 3. Else\n    else\n        // a. Let r be the result of calling the BestFitMatcher abstract\n        //    operation (defined in 9.2.4) with arguments availableLocales and\n        //    requestedLocales.\n        r = BestFitMatcher(availableLocales, requestedLocales);\n\n    // 4. Let foundLocale be the value of r.[[locale]].\n    var foundLocale = r['[[locale]]'];\n\n    var extensionSubtags = void 0,\n        extensionSubtagsLength = void 0;\n\n    // 5. If r has an [[extension]] field, then\n    if (hop.call(r, '[[extension]]')) {\n        // a. Let extension be the value of r.[[extension]].\n        var extension = r['[[extension]]'];\n        // b. Let split be the standard built-in function object defined in ES5,\n        //    15.5.4.14.\n        var split = String.prototype.split;\n        // c. Let extensionSubtags be the result of calling the [[Call]] internal\n        //    method of split with extension as the this value and an argument\n        //    list containing the single item \"-\".\n        extensionSubtags = split.call(extension, '-');\n        // d. Let extensionSubtagsLength be the result of calling the [[Get]]\n        //    internal method of extensionSubtags with argument \"length\".\n        extensionSubtagsLength = extensionSubtags.length;\n    }\n\n    // 6. Let result be a new Record.\n    var result = new Record();\n\n    // 7. Set result.[[dataLocale]] to foundLocale.\n    result['[[dataLocale]]'] = foundLocale;\n\n    // 8. Let supportedExtension be \"-u\".\n    var supportedExtension = '-u';\n    // 9. Let i be 0.\n    var i = 0;\n    // 10. Let len be the result of calling the [[Get]] internal method of\n    //     relevantExtensionKeys with argument \"length\".\n    var len = relevantExtensionKeys.length;\n\n    // 11 Repeat while i < len:\n    while (i < len) {\n        // a. Let key be the result of calling the [[Get]] internal method of\n        //    relevantExtensionKeys with argument ToString(i).\n        var key = relevantExtensionKeys[i];\n        // b. Let foundLocaleData be the result of calling the [[Get]] internal\n        //    method of localeData with the argument foundLocale.\n        var foundLocaleData = localeData[foundLocale];\n        // c. Let keyLocaleData be the result of calling the [[Get]] internal\n        //    method of foundLocaleData with the argument key.\n        var keyLocaleData = foundLocaleData[key];\n        // d. Let value be the result of calling the [[Get]] internal method of\n        //    keyLocaleData with argument \"0\".\n        var value = keyLocaleData['0'];\n        // e. Let supportedExtensionAddition be \"\".\n        var supportedExtensionAddition = '';\n        // f. Let indexOf be the standard built-in function object defined in\n        //    ES5, 15.4.4.14.\n        var indexOf = arrIndexOf;\n\n        // g. If extensionSubtags is not undefined, then\n        if (extensionSubtags !== undefined) {\n            // i. Let keyPos be the result of calling the [[Call]] internal\n            //    method of indexOf with extensionSubtags as the this value and\n            // an argument list containing the single item key.\n            var keyPos = indexOf.call(extensionSubtags, key);\n\n            // ii. If keyPos ≠ -1, then\n            if (keyPos !== -1) {\n                // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n                //    result of calling the [[Get]] internal method of\n                //    extensionSubtags with argument ToString(keyPos +1) is greater\n                //    than 2, then\n                if (keyPos + 1 < extensionSubtagsLength && extensionSubtags[keyPos + 1].length > 2) {\n                    // a. Let requestedValue be the result of calling the [[Get]]\n                    //    internal method of extensionSubtags with argument\n                    //    ToString(keyPos + 1).\n                    var requestedValue = extensionSubtags[keyPos + 1];\n                    // b. Let valuePos be the result of calling the [[Call]]\n                    //    internal method of indexOf with keyLocaleData as the\n                    //    this value and an argument list containing the single\n                    //    item requestedValue.\n                    var valuePos = indexOf.call(keyLocaleData, requestedValue);\n\n                    // c. If valuePos ≠ -1, then\n                    if (valuePos !== -1) {\n                        // i. Let value be requestedValue.\n                        value = requestedValue,\n                        // ii. Let supportedExtensionAddition be the\n                        //     concatenation of \"-\", key, \"-\", and value.\n                        supportedExtensionAddition = '-' + key + '-' + value;\n                    }\n                }\n                // 2. Else\n                else {\n                        // a. Let valuePos be the result of calling the [[Call]]\n                        // internal method of indexOf with keyLocaleData as the this\n                        // value and an argument list containing the single item\n                        // \"true\".\n                        var _valuePos = indexOf(keyLocaleData, 'true');\n\n                        // b. If valuePos ≠ -1, then\n                        if (_valuePos !== -1)\n                            // i. Let value be \"true\".\n                            value = 'true';\n                    }\n            }\n        }\n        // h. If options has a field [[<key>]], then\n        if (hop.call(options, '[[' + key + ']]')) {\n            // i. Let optionsValue be the value of options.[[<key>]].\n            var optionsValue = options['[[' + key + ']]'];\n\n            // ii. If the result of calling the [[Call]] internal method of indexOf\n            //     with keyLocaleData as the this value and an argument list\n            //     containing the single item optionsValue is not -1, then\n            if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n                // 1. If optionsValue is not equal to value, then\n                if (optionsValue !== value) {\n                    // a. Let value be optionsValue.\n                    value = optionsValue;\n                    // b. Let supportedExtensionAddition be \"\".\n                    supportedExtensionAddition = '';\n                }\n            }\n        }\n        // i. Set result.[[<key>]] to value.\n        result['[[' + key + ']]'] = value;\n\n        // j. Append supportedExtensionAddition to supportedExtension.\n        supportedExtension += supportedExtensionAddition;\n\n        // k. Increase i by 1.\n        i++;\n    }\n    // 12. If the length of supportedExtension is greater than 2, then\n    if (supportedExtension.length > 2) {\n        // a.\n        var privateIndex = foundLocale.indexOf(\"-x-\");\n        // b.\n        if (privateIndex === -1) {\n            // i.\n            foundLocale = foundLocale + supportedExtension;\n        }\n        // c.\n        else {\n                // i.\n                var preExtension = foundLocale.substring(0, privateIndex);\n                // ii.\n                var postExtension = foundLocale.substring(privateIndex);\n                // iii.\n                foundLocale = preExtension + supportedExtension + postExtension;\n            }\n        // d. asserting - skipping\n        // e.\n        foundLocale = CanonicalizeLanguageTag(foundLocale);\n    }\n    // 13. Set result.[[locale]] to foundLocale.\n    result['[[locale]]'] = foundLocale;\n\n    // 14. Return result.\n    return result;\n}\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n * The following steps are taken:\n */\nfunction /* 9.2.6 */LookupSupportedLocales(availableLocales, requestedLocales) {\n    // 1. Let len be the number of elements in requestedLocales.\n    var len = requestedLocales.length;\n    // 2. Let subset be a new empty List.\n    var subset = new List();\n    // 3. Let k be 0.\n    var k = 0;\n\n    // 4. Repeat while k < len\n    while (k < len) {\n        // a. Let locale be the element of requestedLocales at 0-origined list\n        //    position k.\n        var locale = requestedLocales[k];\n        // b. Let noExtensionsLocale be the String value that is locale with all\n        //    Unicode locale extension sequences removed.\n        var noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n        // c. Let availableLocale be the result of calling the\n        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n        //    arguments availableLocales and noExtensionsLocale.\n        var availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. If availableLocale is not undefined, then append locale to the end of\n        //    subset.\n        if (availableLocale !== undefined) arrPush.call(subset, locale);\n\n        // e. Increment k by 1.\n        k++;\n    }\n\n    // 5. Let subsetArray be a new Array object whose elements are the same\n    //    values in the same order as the elements of subset.\n    var subsetArray = arrSlice.call(subset);\n\n    // 6. Return subsetArray.\n    return subsetArray;\n}\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the Best Fit Matcher\n * algorithm. Locales appear in the same order in the returned list as in\n * requestedLocales. The steps taken are implementation dependent.\n */\nfunction /*9.2.7 */BestFitSupportedLocales(availableLocales, requestedLocales) {\n    // ###TODO: implement this function as described by the specification###\n    return LookupSupportedLocales(availableLocales, requestedLocales);\n}\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP\n * 47 language priority list requestedLocales for which availableLocales has a\n * matching locale. Two algorithms are available to match the locales: the Lookup\n * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as\n * in requestedLocales. The following steps are taken:\n */\nfunction /*9.2.8 */SupportedLocales(availableLocales, requestedLocales, options) {\n    var matcher = void 0,\n        subset = void 0;\n\n    // 1. If options is not undefined, then\n    if (options !== undefined) {\n        // a. Let options be ToObject(options).\n        options = new Record(toObject(options));\n        // b. Let matcher be the result of calling the [[Get]] internal method of\n        //    options with argument \"localeMatcher\".\n        matcher = options.localeMatcher;\n\n        // c. If matcher is not undefined, then\n        if (matcher !== undefined) {\n            // i. Let matcher be ToString(matcher).\n            matcher = String(matcher);\n\n            // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n            //     exception.\n            if (matcher !== 'lookup' && matcher !== 'best fit') throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n        }\n    }\n    // 2. If matcher is undefined or \"best fit\", then\n    if (matcher === undefined || matcher === 'best fit')\n        // a. Let subset be the result of calling the BestFitSupportedLocales\n        //    abstract operation (defined in 9.2.7) with arguments\n        //    availableLocales and requestedLocales.\n        subset = BestFitSupportedLocales(availableLocales, requestedLocales);\n        // 3. Else\n    else\n        // a. Let subset be the result of calling the LookupSupportedLocales\n        //    abstract operation (defined in 9.2.6) with arguments\n        //    availableLocales and requestedLocales.\n        subset = LookupSupportedLocales(availableLocales, requestedLocales);\n\n    // 4. For each named own property name P of subset,\n    for (var P in subset) {\n        if (!hop.call(subset, P)) continue;\n\n        // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n        //    method of subset with P.\n        // b. Set desc.[[Writable]] to false.\n        // c. Set desc.[[Configurable]] to false.\n        // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n        //    and true as arguments.\n        defineProperty(subset, P, {\n            writable: false, configurable: false, value: subset[P]\n        });\n    }\n    // \"Freeze\" the array so no new elements can be added\n    defineProperty(subset, 'length', { writable: false });\n\n    // 5. Return subset\n    return subset;\n}\n\n/**\n * The GetOption abstract operation extracts the value of the property named\n * property from the provided options object, converts it to the required type,\n * checks whether it is one of a List of allowed values, and fills in a fallback\n * value if necessary.\n */\nfunction /*9.2.9 */GetOption(options, property, type, values, fallback) {\n    // 1. Let value be the result of calling the [[Get]] internal method of\n    //    options with argument property.\n    var value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Assert: type is \"boolean\" or \"string\".\n        // b. If type is \"boolean\", then let value be ToBoolean(value).\n        // c. If type is \"string\", then let value be ToString(value).\n        value = type === 'boolean' ? Boolean(value) : type === 'string' ? String(value) : value;\n\n        // d. If values is not undefined, then\n        if (values !== undefined) {\n            // i. If values does not contain an element equal to value, then throw a\n            //    RangeError exception.\n            if (arrIndexOf.call(values, value) === -1) throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property + '`');\n        }\n\n        // e. Return value.\n        return value;\n    }\n    // Else return fallback.\n    return fallback;\n}\n\n/**\n * The GetNumberOption abstract operation extracts a property value from the\n * provided options object, converts it to a Number value, checks whether it is\n * in the allowed range, and fills in a fallback value if necessary.\n */\nfunction /* 9.2.10 */GetNumberOption(options, property, minimum, maximum, fallback) {\n    // 1. Let value be the result of calling the [[Get]] internal method of\n    //    options with argument property.\n    var value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Let value be ToNumber(value).\n        value = Number(value);\n\n        // b. If value is NaN or less than minimum or greater than maximum, throw a\n        //    RangeError exception.\n        if (isNaN(value) || value < minimum || value > maximum) throw new RangeError('Value is not a number or outside accepted range');\n\n        // c. Return floor(value).\n        return Math.floor(value);\n    }\n    // 3. Else return fallback.\n    return fallback;\n}\n\n// 8 The Intl Object\nvar Intl = {};\n\n// 8.2 Function Properties of the Intl Object\n\n// 8.2.1\n// @spec[tc39/ecma402/master/spec/intl.html]\n// @clause[sec-intl.getcanonicallocales]\nfunction getCanonicalLocales(locales) {\n    // 1. Let ll be ? CanonicalizeLocaleList(locales).\n    var ll = CanonicalizeLocaleList(locales);\n    // 2. Return CreateArrayFromList(ll).\n    {\n        var result = [];\n\n        var len = ll.length;\n        var k = 0;\n\n        while (k < len) {\n            result[k] = ll[k];\n            k++;\n        }\n        return result;\n    }\n}\n\nObject.defineProperty(Intl, 'getCanonicalLocales', {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: getCanonicalLocales\n});\n\n// Currency minor units output from get-4217 grunt task, formatted\nvar currencyMinorUnits = {\n    BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\n    XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\n    OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0\n};\n\n// Define the NumberFormat constructor internally so it cannot be tainted\nfunction NumberFormatConstructor() {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.NumberFormat(locales, options);\n    }\n\n    return InitializeNumberFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'NumberFormat', {\n    configurable: true,\n    writable: true,\n    value: NumberFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(Intl.NumberFormat, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeNumberFormat accepts the arguments\n * numberFormat (which must be an object), locales, and options. It initializes\n * numberFormat as a NumberFormat object.\n */\nfunction /*11.1.1.1 */InitializeNumberFormat(numberFormat, locales, options) {\n    // This will be a internal properties object if we're not already initialized\n    var internal = getInternalProperties(numberFormat);\n\n    // Create an object whose props can be used to restore the values of RegExp props\n    var regexpRestore = createRegExpRestore();\n\n    // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n    // value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(numberFormat, '__getInternalProperties', {\n        value: function value() {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret) return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    var requestedLocales = CanonicalizeLocaleList(locales);\n\n    // 4. If options is undefined, then\n    if (options === undefined)\n        // a. Let options be the result of creating a new object as if by the\n        // expression new Object() where Object is the standard built-in constructor\n        // with that name.\n        options = {};\n\n        // 5. Else\n    else\n        // a. Let options be ToObject(options).\n        options = toObject(options);\n\n    // 6. Let opt be a new Record.\n    var opt = new Record(),\n\n\n    // 7. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n    //    a List containing the two String values \"lookup\" and \"best fit\", and\n    //    \"best fit\".\n    matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 8. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    // 9. Let NumberFormat be the standard built-in object that is the initial value\n    //    of Intl.NumberFormat.\n    // 10. Let localeData be the value of the [[localeData]] internal property of\n    //     NumberFormat.\n    var localeData = internals.NumberFormat['[[localeData]]'];\n\n    // 11. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //     internal property of NumberFormat, and localeData.\n    var r = ResolveLocale(internals.NumberFormat['[[availableLocales]]'], requestedLocales, opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData);\n\n    // 12. Set the [[locale]] internal property of numberFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n    //     of r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n    var dataLocale = r['[[dataLocale]]'];\n\n    // 15. Let s be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"style\", \"string\", a List containing the three String\n    //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n    var s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\n\n    // 16. Set the [[style]] internal property of numberFormat to s.\n    internal['[[style]]'] = s;\n\n    // 17. Let c be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currency\", \"string\", undefined, and undefined.\n    var c = GetOption(options, 'currency', 'string');\n\n    // 18. If c is not undefined and the result of calling the\n    //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n    //     argument c is false, then throw a RangeError exception.\n    if (c !== undefined && !IsWellFormedCurrencyCode(c)) throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\n\n    // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n    if (s === 'currency' && c === undefined) throw new TypeError('Currency code is required when style is currency');\n\n    var cDigits = void 0;\n\n    // 20. If s is \"currency\", then\n    if (s === 'currency') {\n        // a. Let c be the result of converting c to upper case as specified in 6.1.\n        c = c.toUpperCase();\n\n        // b. Set the [[currency]] internal property of numberFormat to c.\n        internal['[[currency]]'] = c;\n\n        // c. Let cDigits be the result of calling the CurrencyDigits abstract\n        //    operation (defined below) with argument c.\n        cDigits = CurrencyDigits(c);\n    }\n\n    // 21. Let cd be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n    //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n    var cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\n\n    // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n    //     numberFormat to cd.\n    if (s === 'currency') internal['[[currencyDisplay]]'] = cd;\n\n    // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n    //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n    //     and 1.\n    var mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\n\n    // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n    internal['[[minimumIntegerDigits]]'] = mnid;\n\n    // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n    //     be 0.\n    var mnfdDefault = s === 'currency' ? cDigits : 0;\n\n    // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n    var mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\n\n    // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n    internal['[[minimumFractionDigits]]'] = mnfd;\n\n    // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n    //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n    //     be max(mnfd, 3).\n    var mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits) : s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3);\n\n    // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n    var mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault);\n\n    // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n    internal['[[maximumFractionDigits]]'] = mxfd;\n\n    // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"minimumSignificantDigits\".\n    var mnsd = options.minimumSignificantDigits;\n\n    // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"maximumSignificantDigits\".\n    var mxsd = options.maximumSignificantDigits;\n\n    // 33. If mnsd is not undefined or mxsd is not undefined, then:\n    if (mnsd !== undefined || mxsd !== undefined) {\n        // a. Let mnsd be the result of calling the GetNumberOption abstract\n        //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n        //    and 1.\n        mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1);\n\n        // b. Let mxsd be the result of calling the GetNumberOption abstract\n        //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n        //     21, and 21.\n        mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21);\n\n        // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n        //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n        //    numberFormat to mxsd.\n        internal['[[minimumSignificantDigits]]'] = mnsd;\n        internal['[[maximumSignificantDigits]]'] = mxsd;\n    }\n    // 34. Let g be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n    var g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\n\n    // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n    internal['[[useGrouping]]'] = g;\n\n    // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n    //     localeData with argument dataLocale.\n    var dataLocaleData = localeData[dataLocale];\n\n    // 37. Let patterns be the result of calling the [[Get]] internal method of\n    //     dataLocaleData with argument \"patterns\".\n    var patterns = dataLocaleData.patterns;\n\n    // 38. Assert: patterns is an object (see 11.2.3)\n\n    // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n    //     patterns with argument s.\n    var stylePatterns = patterns[s];\n\n    // 40. Set the [[positivePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"positivePattern\".\n    internal['[[positivePattern]]'] = stylePatterns.positivePattern;\n\n    // 41. Set the [[negativePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"negativePattern\".\n    internal['[[negativePattern]]'] = stylePatterns.negativePattern;\n\n    // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n    //     true.\n    internal['[[initializedNumberFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3) numberFormat.format = GetFormatNumber.call(numberFormat);\n\n    // Restore the RegExp properties\n    regexpRestore();\n\n    // Return the newly initialised object\n    return numberFormat;\n}\n\nfunction CurrencyDigits(currency) {\n    // When the CurrencyDigits abstract operation is called with an argument currency\n    // (which must be an upper case String value), the following steps are taken:\n\n    // 1. If the ISO 4217 currency and funds code list contains currency as an\n    // alphabetic code, then return the minor unit value corresponding to the\n    // currency from the list; else return 2.\n    return currencyMinorUnits[currency] !== undefined ? currencyMinorUnits[currency] : 2;\n}\n\n/* 11.2.3 */internals.NumberFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n * following steps are taken:\n */\n/* 11.2.2 */\ndefineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(function (locales) {\n        // Bound functions only have the `this` value altered if being used as a constructor,\n        // this lets us imitate a native function that has no constructor\n        if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor');\n\n        // Create an object whose props can be used to restore the values of RegExp props\n        var regexpRestore = createRegExpRestore(),\n\n\n        // 1. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n        //    property of the standard built-in object that is the initial value of\n        //    Intl.NumberFormat.\n\n        availableLocales = this['[[availableLocales]]'],\n\n\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n        //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n        // Restore the RegExp properties\n        regexpRestore();\n\n        // 4. Return the result of calling the SupportedLocales abstract operation\n        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n        //    and options.\n        return SupportedLocales(availableLocales, requestedLocales, options);\n    }, internals.NumberFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * NumberFormat object.\n */\n/* 11.3.2 */defineProperty(Intl.NumberFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatNumber\n});\n\nfunction GetFormatNumber() {\n    var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n    // Satisfy test 11.3_b\n    if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\n\n    // The value of the [[Get]] attribute is a function that takes the following\n    // steps:\n\n    // 1. If the [[boundFormat]] internal property of this NumberFormat object\n    //    is undefined, then:\n    if (internal['[[boundFormat]]'] === undefined) {\n        // a. Let F be a Function object, with internal properties set as\n        //    specified for built-in functions in ES5, 15, or successor, and the\n        //    length property set to 1, that takes the argument value and\n        //    performs the following steps:\n        var F = function F(value) {\n            // i. If value is not provided, then let value be undefined.\n            // ii. Let x be ToNumber(value).\n            // iii. Return the result of calling the FormatNumber abstract\n            //      operation (defined below) with arguments this and x.\n            return FormatNumber(this, /* x = */Number(value));\n        };\n\n        // b. Let bind be the standard built-in function object defined in ES5,\n        //    15.3.4.5.\n        // c. Let bf be the result of calling the [[Call]] internal method of\n        //    bind with F as the this value and an argument list containing\n        //    the single item this.\n        var bf = fnBind.call(F, this);\n\n        // d. Set the [[boundFormat]] internal property of this NumberFormat\n        //    object to bf.\n        internal['[[boundFormat]]'] = bf;\n    }\n    // Return the value of the [[boundFormat]] internal property of this\n    // NumberFormat object.\n    return internal['[[boundFormat]]'];\n}\n\nfunction formatToParts() {\n    var value = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n\n    var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n    if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.NumberFormat object.');\n\n    var x = Number(value);\n    return FormatNumberToParts(this, x);\n}\n\nObject.defineProperty(Intl.NumberFormat.prototype, 'formatToParts', {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: formatToParts\n});\n\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-formatnumbertoparts]\n */\nfunction FormatNumberToParts(numberFormat, x) {\n    // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n    var parts = PartitionNumberPattern(numberFormat, x);\n    // 2. Let result be ArrayCreate(0).\n    var result = [];\n    // 3. Let n be 0.\n    var n = 0;\n    // 4. For each part in parts, do:\n    for (var i = 0; parts.length > i; i++) {\n        var part = parts[i];\n        // a. Let O be ObjectCreate(%ObjectPrototype%).\n        var O = {};\n        // a. Perform ? CreateDataPropertyOrThrow(O, \"type\", part.[[type]]).\n        O.type = part['[[type]]'];\n        // a. Perform ? CreateDataPropertyOrThrow(O, \"value\", part.[[value]]).\n        O.value = part['[[value]]'];\n        // a. Perform ? CreateDataPropertyOrThrow(result, ? ToString(n), O).\n        result[n] = O;\n        // a. Increment n by 1.\n        n += 1;\n    }\n    // 5. Return result.\n    return result;\n}\n\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-partitionnumberpattern]\n */\nfunction PartitionNumberPattern(numberFormat, x) {\n\n    var internal = getInternalProperties(numberFormat),\n        locale = internal['[[dataLocale]]'],\n        nums = internal['[[numberingSystem]]'],\n        data = internals.NumberFormat['[[localeData]]'][locale],\n        ild = data.symbols[nums] || data.symbols.latn,\n        pattern = void 0;\n\n    // 1. If x is not NaN and x < 0, then:\n    if (!isNaN(x) && x < 0) {\n        // a. Let x be -x.\n        x = -x;\n        // a. Let pattern be the value of numberFormat.[[negativePattern]].\n        pattern = internal['[[negativePattern]]'];\n    }\n    // 2. Else,\n    else {\n            // a. Let pattern be the value of numberFormat.[[positivePattern]].\n            pattern = internal['[[positivePattern]]'];\n        }\n    // 3. Let result be a new empty List.\n    var result = new List();\n    // 4. Let beginIndex be Call(%StringProto_indexOf%, pattern, \"{\", 0).\n    var beginIndex = pattern.indexOf('{', 0);\n    // 5. Let endIndex be 0.\n    var endIndex = 0;\n    // 6. Let nextIndex be 0.\n    var nextIndex = 0;\n    // 7. Let length be the number of code units in pattern.\n    var length = pattern.length;\n    // 8. Repeat while beginIndex is an integer index into pattern:\n    while (beginIndex > -1 && beginIndex < length) {\n        // a. Set endIndex to Call(%StringProto_indexOf%, pattern, \"}\", beginIndex)\n        endIndex = pattern.indexOf('}', beginIndex);\n        // a. If endIndex = -1, throw new Error exception.\n        if (endIndex === -1) throw new Error();\n        // a. If beginIndex is greater than nextIndex, then:\n        if (beginIndex > nextIndex) {\n            // i. Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n            var literal = pattern.substring(nextIndex, beginIndex);\n            // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n            arrPush.call(result, { '[[type]]': 'literal', '[[value]]': literal });\n        }\n        // a. Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n        var p = pattern.substring(beginIndex + 1, endIndex);\n        // a. If p is equal \"number\", then:\n        if (p === \"number\") {\n            // i. If x is NaN,\n            if (isNaN(x)) {\n                // 1. Let n be an ILD String value indicating the NaN value.\n                var n = ild.nan;\n                // 2. Add new part record { [[type]]: \"nan\", [[value]]: n } as a new element of the list result.\n                arrPush.call(result, { '[[type]]': 'nan', '[[value]]': n });\n            }\n            // ii. Else if isFinite(x) is false,\n            else if (!isFinite(x)) {\n                    // 1. Let n be an ILD String value indicating infinity.\n                    var _n = ild.infinity;\n                    // 2. Add new part record { [[type]]: \"infinity\", [[value]]: n } as a new element of the list result.\n                    arrPush.call(result, { '[[type]]': 'infinity', '[[value]]': _n });\n                }\n                // iii. Else,\n                else {\n                        // 1. If the value of numberFormat.[[style]] is \"percent\" and isFinite(x), let x be 100 × x.\n                        if (internal['[[style]]'] === 'percent' && isFinite(x)) x *= 100;\n\n                        var _n2 = void 0;\n                        // 2. If the numberFormat.[[minimumSignificantDigits]] and numberFormat.[[maximumSignificantDigits]] are present, then\n                        if (hop.call(internal, '[[minimumSignificantDigits]]') && hop.call(internal, '[[maximumSignificantDigits]]')) {\n                            // a. Let n be ToRawPrecision(x, numberFormat.[[minimumSignificantDigits]], numberFormat.[[maximumSignificantDigits]]).\n                            _n2 = ToRawPrecision(x, internal['[[minimumSignificantDigits]]'], internal['[[maximumSignificantDigits]]']);\n                        }\n                        // 3. Else,\n                        else {\n                                // a. Let n be ToRawFixed(x, numberFormat.[[minimumIntegerDigits]], numberFormat.[[minimumFractionDigits]], numberFormat.[[maximumFractionDigits]]).\n                                _n2 = ToRawFixed(x, internal['[[minimumIntegerDigits]]'], internal['[[minimumFractionDigits]]'], internal['[[maximumFractionDigits]]']);\n                            }\n                        // 4. If the value of the numberFormat.[[numberingSystem]] matches one of the values in the \"Numbering System\" column of Table 2 below, then\n                        if (numSys[nums]) {\n                            (function () {\n                                // a. Let digits be an array whose 10 String valued elements are the UTF-16 string representations of the 10 digits specified in the \"Digits\" column of the matching row in Table 2.\n                                var digits = numSys[nums];\n                                // a. Replace each digit in n with the value of digits[digit].\n                                _n2 = String(_n2).replace(/\\d/g, function (digit) {\n                                    return digits[digit];\n                                });\n                            })();\n                        }\n                        // 5. Else use an implementation dependent algorithm to map n to the appropriate representation of n in the given numbering system.\n                        else _n2 = String(_n2); // ###TODO###\n\n                        var integer = void 0;\n                        var fraction = void 0;\n                        // 6. Let decimalSepIndex be Call(%StringProto_indexOf%, n, \".\", 0).\n                        var decimalSepIndex = _n2.indexOf('.', 0);\n                        // 7. If decimalSepIndex > 0, then:\n                        if (decimalSepIndex > 0) {\n                            // a. Let integer be the substring of n from position 0, inclusive, to position decimalSepIndex, exclusive.\n                            integer = _n2.substring(0, decimalSepIndex);\n                            // a. Let fraction be the substring of n from position decimalSepIndex, exclusive, to the end of n.\n                            fraction = _n2.substring(decimalSepIndex + 1, decimalSepIndex.length);\n                        }\n                        // 8. Else:\n                        else {\n                                // a. Let integer be n.\n                                integer = _n2;\n                                // a. Let fraction be undefined.\n                                fraction = undefined;\n                            }\n                        // 9. If the value of the numberFormat.[[useGrouping]] is true,\n                        if (internal['[[useGrouping]]'] === true) {\n                            // a. Let groupSepSymbol be the ILND String representing the grouping separator.\n                            var groupSepSymbol = ild.group;\n                            // a. Let groups be a List whose elements are, in left to right order, the substrings defined by ILND set of locations within the integer.\n                            var groups = [];\n                            // ----> implementation:\n                            // Primary group represents the group closest to the decimal\n                            var pgSize = data.patterns.primaryGroupSize || 3;\n                            // Secondary group is every other group\n                            var sgSize = data.patterns.secondaryGroupSize || pgSize;\n                            // Group only if necessary\n                            if (integer.length > pgSize) {\n                                // Index of the primary grouping separator\n                                var end = integer.length - pgSize;\n                                // Starting index for our loop\n                                var idx = end % sgSize;\n                                var start = integer.slice(0, idx);\n                                if (start.length) arrPush.call(groups, start);\n                                // Loop to separate into secondary grouping digits\n                                while (idx < end) {\n                                    arrPush.call(groups, integer.slice(idx, idx + sgSize));\n                                    idx += sgSize;\n                                }\n                                // Add the primary grouping digits\n                                arrPush.call(groups, integer.slice(end));\n                            } else {\n                                arrPush.call(groups, integer);\n                            }\n                            // a. Assert: The number of elements in groups List is greater than 0.\n                            if (groups.length === 0) throw new Error();\n                            // a. Repeat, while groups List is not empty:\n                            while (groups.length) {\n                                // i. Remove the first element from groups and let integerGroup be the value of that element.\n                                var integerGroup = arrShift.call(groups);\n                                // ii. Add new part record { [[type]]: \"integer\", [[value]]: integerGroup } as a new element of the list result.\n                                arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integerGroup });\n                                // iii. If groups List is not empty, then:\n                                if (groups.length) {\n                                    // 1. Add new part record { [[type]]: \"group\", [[value]]: groupSepSymbol } as a new element of the list result.\n                                    arrPush.call(result, { '[[type]]': 'group', '[[value]]': groupSepSymbol });\n                                }\n                            }\n                        }\n                        // 10. Else,\n                        else {\n                                // a. Add new part record { [[type]]: \"integer\", [[value]]: integer } as a new element of the list result.\n                                arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integer });\n                            }\n                        // 11. If fraction is not undefined, then:\n                        if (fraction !== undefined) {\n                            // a. Let decimalSepSymbol be the ILND String representing the decimal separator.\n                            var decimalSepSymbol = ild.decimal;\n                            // a. Add new part record { [[type]]: \"decimal\", [[value]]: decimalSepSymbol } as a new element of the list result.\n                            arrPush.call(result, { '[[type]]': 'decimal', '[[value]]': decimalSepSymbol });\n                            // a. Add new part record { [[type]]: \"fraction\", [[value]]: fraction } as a new element of the list result.\n                            arrPush.call(result, { '[[type]]': 'fraction', '[[value]]': fraction });\n                        }\n                    }\n        }\n        // a. Else if p is equal \"plusSign\", then:\n        else if (p === \"plusSign\") {\n                // i. Let plusSignSymbol be the ILND String representing the plus sign.\n                var plusSignSymbol = ild.plusSign;\n                // ii. Add new part record { [[type]]: \"plusSign\", [[value]]: plusSignSymbol } as a new element of the list result.\n                arrPush.call(result, { '[[type]]': 'plusSign', '[[value]]': plusSignSymbol });\n            }\n            // a. Else if p is equal \"minusSign\", then:\n            else if (p === \"minusSign\") {\n                    // i. Let minusSignSymbol be the ILND String representing the minus sign.\n                    var minusSignSymbol = ild.minusSign;\n                    // ii. Add new part record { [[type]]: \"minusSign\", [[value]]: minusSignSymbol } as a new element of the list result.\n                    arrPush.call(result, { '[[type]]': 'minusSign', '[[value]]': minusSignSymbol });\n                }\n                // a. Else if p is equal \"percentSign\" and numberFormat.[[style]] is \"percent\", then:\n                else if (p === \"percentSign\" && internal['[[style]]'] === \"percent\") {\n                        // i. Let percentSignSymbol be the ILND String representing the percent sign.\n                        var percentSignSymbol = ild.percentSign;\n                        // ii. Add new part record { [[type]]: \"percentSign\", [[value]]: percentSignSymbol } as a new element of the list result.\n                        arrPush.call(result, { '[[type]]': 'literal', '[[value]]': percentSignSymbol });\n                    }\n                    // a. Else if p is equal \"currency\" and numberFormat.[[style]] is \"currency\", then:\n                    else if (p === \"currency\" && internal['[[style]]'] === \"currency\") {\n                            // i. Let currency be the value of numberFormat.[[currency]].\n                            var currency = internal['[[currency]]'];\n\n                            var cd = void 0;\n\n                            // ii. If numberFormat.[[currencyDisplay]] is \"code\", then\n                            if (internal['[[currencyDisplay]]'] === \"code\") {\n                                // 1. Let cd be currency.\n                                cd = currency;\n                            }\n                            // iii. Else if numberFormat.[[currencyDisplay]] is \"symbol\", then\n                            else if (internal['[[currencyDisplay]]'] === \"symbol\") {\n                                    // 1. Let cd be an ILD string representing currency in short form. If the implementation does not have such a representation of currency, use currency itself.\n                                    cd = data.currencies[currency] || currency;\n                                }\n                                // iv. Else if numberFormat.[[currencyDisplay]] is \"name\", then\n                                else if (internal['[[currencyDisplay]]'] === \"name\") {\n                                        // 1. Let cd be an ILD string representing currency in long form. If the implementation does not have such a representation of currency, then use currency itself.\n                                        cd = currency;\n                                    }\n                            // v. Add new part record { [[type]]: \"currency\", [[value]]: cd } as a new element of the list result.\n                            arrPush.call(result, { '[[type]]': 'currency', '[[value]]': cd });\n                        }\n                        // a. Else,\n                        else {\n                                // i. Let literal be the substring of pattern from position beginIndex, inclusive, to position endIndex, inclusive.\n                                var _literal = pattern.substring(beginIndex, endIndex);\n                                // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n                                arrPush.call(result, { '[[type]]': 'literal', '[[value]]': _literal });\n                            }\n        // a. Set nextIndex to endIndex + 1.\n        nextIndex = endIndex + 1;\n        // a. Set beginIndex to Call(%StringProto_indexOf%, pattern, \"{\", nextIndex)\n        beginIndex = pattern.indexOf('{', nextIndex);\n    }\n    // 9. If nextIndex is less than length, then:\n    if (nextIndex < length) {\n        // a. Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\n        var _literal2 = pattern.substring(nextIndex, length);\n        // a. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n        arrPush.call(result, { '[[type]]': 'literal', '[[value]]': _literal2 });\n    }\n    // 10. Return result.\n    return result;\n}\n\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-formatnumber]\n */\nfunction FormatNumber(numberFormat, x) {\n    // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n    var parts = PartitionNumberPattern(numberFormat, x);\n    // 2. Let result be an empty String.\n    var result = '';\n    // 3. For each part in parts, do:\n    for (var i = 0; parts.length > i; i++) {\n        var part = parts[i];\n        // a. Set result to a String value produced by concatenating result and part.[[value]].\n        result += part['[[value]]'];\n    }\n    // 4. Return result.\n    return result;\n}\n\n/**\n * When the ToRawPrecision abstract operation is called with arguments x (which\n * must be a finite non-negative number), minPrecision, and maxPrecision (both\n * must be integers between 1 and 21) the following steps are taken:\n */\nfunction ToRawPrecision(x, minPrecision, maxPrecision) {\n    // 1. Let p be maxPrecision.\n    var p = maxPrecision;\n\n    var m = void 0,\n        e = void 0;\n\n    // 2. If x = 0, then\n    if (x === 0) {\n        // a. Let m be the String consisting of p occurrences of the character \"0\".\n        m = arrJoin.call(Array(p + 1), '0');\n        // b. Let e be 0.\n        e = 0;\n    }\n    // 3. Else\n    else {\n            // a. Let e and n be integers such that 10ᵖ⁻¹ ≤ n < 10ᵖ and for which the\n            //    exact mathematical value of n × 10ᵉ⁻ᵖ⁺¹ – x is as close to zero as\n            //    possible. If there are two such sets of e and n, pick the e and n for\n            //    which n × 10ᵉ⁻ᵖ⁺¹ is larger.\n            e = log10Floor(Math.abs(x));\n\n            // Easier to get to m from here\n            var f = Math.round(Math.exp(Math.abs(e - p + 1) * Math.LN10));\n\n            // b. Let m be the String consisting of the digits of the decimal\n            //    representation of n (in order, with no leading zeroes)\n            m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n        }\n\n    // 4. If e ≥ p, then\n    if (e >= p)\n        // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n        return m + arrJoin.call(Array(e - p + 1 + 1), '0');\n\n        // 5. If e = p-1, then\n    else if (e === p - 1)\n            // a. Return m.\n            return m;\n\n            // 6. If e ≥ 0, then\n        else if (e >= 0)\n                // a. Let m be the concatenation of the first e+1 characters of m, the character\n                //    \".\", and the remaining p–(e+1) characters of m.\n                m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\n\n                // 7. If e < 0, then\n            else if (e < 0)\n                    // a. Let m be the concatenation of the String \"0.\", –(e+1) occurrences of the\n                    //    character \"0\", and the string m.\n                    m = '0.' + arrJoin.call(Array(-(e + 1) + 1), '0') + m;\n\n    // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n    if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n        // a. Let cut be maxPrecision – minPrecision.\n        var cut = maxPrecision - minPrecision;\n\n        // b. Repeat while cut > 0 and the last character of m is \"0\":\n        while (cut > 0 && m.charAt(m.length - 1) === '0') {\n            //  i. Remove the last character from m.\n            m = m.slice(0, -1);\n\n            //  ii. Decrease cut by 1.\n            cut--;\n        }\n\n        // c. If the last character of m is \".\", then\n        if (m.charAt(m.length - 1) === '.')\n            //    i. Remove the last character from m.\n            m = m.slice(0, -1);\n    }\n    // 9. Return m.\n    return m;\n}\n\n/**\n * @spec[tc39/ecma402/master/spec/numberformat.html]\n * @clause[sec-torawfixed]\n * When the ToRawFixed abstract operation is called with arguments x (which must\n * be a finite non-negative number), minInteger (which must be an integer between\n * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n * 20) the following steps are taken:\n */\nfunction ToRawFixed(x, minInteger, minFraction, maxFraction) {\n    // 1. Let f be maxFraction.\n    var f = maxFraction;\n    // 2. Let n be an integer for which the exact mathematical value of n ÷ 10f – x is as close to zero as possible. If there are two such n, pick the larger n.\n    var n = Math.pow(10, f) * x; // diverging...\n    // 3. If n = 0, let m be the String \"0\". Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes).\n    var m = n === 0 ? \"0\" : n.toFixed(0); // divering...\n\n    {\n        // this diversion is needed to take into consideration big numbers, e.g.:\n        // 1.2344501e+37 -> 12344501000000000000000000000000000000\n        var idx = void 0;\n        var exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n        if (exp) {\n            m = m.slice(0, idx).replace('.', '');\n            m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0');\n        }\n    }\n\n    var int = void 0;\n    // 4. If f ≠ 0, then\n    if (f !== 0) {\n        // a. Let k be the number of characters in m.\n        var k = m.length;\n        // a. If k ≤ f, then\n        if (k <= f) {\n            // i. Let z be the String consisting of f+1–k occurrences of the character \"0\".\n            var z = arrJoin.call(Array(f + 1 - k + 1), '0');\n            // ii. Let m be the concatenation of Strings z and m.\n            m = z + m;\n            // iii. Let k be f+1.\n            k = f + 1;\n        }\n        // a. Let a be the first k–f characters of m, and let b be the remaining f characters of m.\n        var a = m.substring(0, k - f),\n            b = m.substring(k - f, m.length);\n        // a. Let m be the concatenation of the three Strings a, \".\", and b.\n        m = a + \".\" + b;\n        // a. Let int be the number of characters in a.\n        int = a.length;\n    }\n    // 5. Else, let int be the number of characters in m.\n    else int = m.length;\n    // 6. Let cut be maxFraction – minFraction.\n    var cut = maxFraction - minFraction;\n    // 7. Repeat while cut > 0 and the last character of m is \"0\":\n    while (cut > 0 && m.slice(-1) === \"0\") {\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n        // a. Decrease cut by 1.\n        cut--;\n    }\n    // 8. If the last character of m is \".\", then\n    if (m.slice(-1) === \".\") {\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n    }\n    // 9. If int < minInteger, then\n    if (int < minInteger) {\n        // a. Let z be the String consisting of minInteger–int occurrences of the character \"0\".\n        var _z = arrJoin.call(Array(minInteger - int + 1), '0');\n        // a. Let m be the concatenation of Strings z and m.\n        m = _z + m;\n    }\n    // 10. Return m.\n    return m;\n}\n\n// Sect 11.3.2 Table 2, Numbering systems\n// ======================================\nvar numSys = {\n    arab: [\"٠\", \"١\", \"٢\", \"٣\", \"٤\", \"٥\", \"٦\", \"٧\", \"٨\", \"٩\"],\n    arabext: [\"۰\", \"۱\", \"۲\", \"۳\", \"۴\", \"۵\", \"۶\", \"۷\", \"۸\", \"۹\"],\n    bali: [\"᭐\", \"᭑\", \"᭒\", \"᭓\", \"᭔\", \"᭕\", \"᭖\", \"᭗\", \"᭘\", \"᭙\"],\n    beng: [\"০\", \"১\", \"২\", \"৩\", \"৪\", \"৫\", \"৬\", \"৭\", \"৮\", \"৯\"],\n    deva: [\"०\", \"१\", \"२\", \"३\", \"४\", \"५\", \"६\", \"७\", \"८\", \"९\"],\n    fullwide: [\"０\", \"１\", \"２\", \"３\", \"４\", \"５\", \"６\", \"７\", \"８\", \"９\"],\n    gujr: [\"૦\", \"૧\", \"૨\", \"૩\", \"૪\", \"૫\", \"૬\", \"૭\", \"૮\", \"૯\"],\n    guru: [\"੦\", \"੧\", \"੨\", \"੩\", \"੪\", \"੫\", \"੬\", \"੭\", \"੮\", \"੯\"],\n    hanidec: [\"〇\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\", \"七\", \"八\", \"九\"],\n    khmr: [\"០\", \"១\", \"២\", \"៣\", \"៤\", \"៥\", \"៦\", \"៧\", \"៨\", \"៩\"],\n    knda: [\"೦\", \"೧\", \"೨\", \"೩\", \"೪\", \"೫\", \"೬\", \"೭\", \"೮\", \"೯\"],\n    laoo: [\"໐\", \"໑\", \"໒\", \"໓\", \"໔\", \"໕\", \"໖\", \"໗\", \"໘\", \"໙\"],\n    latn: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n    limb: [\"᥆\", \"᥇\", \"᥈\", \"᥉\", \"᥊\", \"᥋\", \"᥌\", \"᥍\", \"᥎\", \"᥏\"],\n    mlym: [\"൦\", \"൧\", \"൨\", \"൩\", \"൪\", \"൫\", \"൬\", \"൭\", \"൮\", \"൯\"],\n    mong: [\"᠐\", \"᠑\", \"᠒\", \"᠓\", \"᠔\", \"᠕\", \"᠖\", \"᠗\", \"᠘\", \"᠙\"],\n    mymr: [\"၀\", \"၁\", \"၂\", \"၃\", \"၄\", \"၅\", \"၆\", \"၇\", \"၈\", \"၉\"],\n    orya: [\"୦\", \"୧\", \"୨\", \"୩\", \"୪\", \"୫\", \"୬\", \"୭\", \"୮\", \"୯\"],\n    tamldec: [\"௦\", \"௧\", \"௨\", \"௩\", \"௪\", \"௫\", \"௬\", \"௭\", \"௮\", \"௯\"],\n    telu: [\"౦\", \"౧\", \"౨\", \"౩\", \"౪\", \"౫\", \"౬\", \"౭\", \"౮\", \"౯\"],\n    thai: [\"๐\", \"๑\", \"๒\", \"๓\", \"๔\", \"๕\", \"๖\", \"๗\", \"๘\", \"๙\"],\n    tibt: [\"༠\", \"༡\", \"༢\", \"༣\", \"༤\", \"༥\", \"༦\", \"༧\", \"༨\", \"༩\"]\n};\n\n/**\n * This function provides access to the locale and formatting options computed\n * during initialization of the object.\n *\n * The function returns a new object whose properties and attributes are set as\n * if constructed by an object literal assigning to each of the following\n * properties the value of the corresponding internal property of this\n * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n * useGrouping. Properties whose corresponding internal properties are not present\n * are not assigned.\n */\n/* 11.3.3 */defineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n    configurable: true,\n    writable: true,\n    value: function value() {\n        var prop = void 0,\n            descs = new Record(),\n            props = ['locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'],\n            internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\n/* jslint esnext: true */\n\n// Match these datetime components in a CLDR pattern, except those in single quotes\nvar expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n// trim patterns after transformations\nvar expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n// Skip over patterns with these datetime components because we don't have data\n// to back them up:\n// timezone, weekday, amoung others\nvar unwantedDTCs = /[rqQASjJgwWIQq]/; // xXVO were removed from this list in favor of computing matches with timeZoneName values but printing as empty string\n\nvar dtKeys = [\"era\", \"year\", \"month\", \"day\", \"weekday\", \"quarter\"];\nvar tmKeys = [\"hour\", \"minute\", \"second\", \"hour12\", \"timeZoneName\"];\n\nfunction isDateFormatOnly(obj) {\n    for (var i = 0; i < tmKeys.length; i += 1) {\n        if (obj.hasOwnProperty(tmKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isTimeFormatOnly(obj) {\n    for (var i = 0; i < dtKeys.length; i += 1) {\n        if (obj.hasOwnProperty(dtKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {\n    var o = { _: {} };\n    for (var i = 0; i < dtKeys.length; i += 1) {\n        if (dateFormatObj[dtKeys[i]]) {\n            o[dtKeys[i]] = dateFormatObj[dtKeys[i]];\n        }\n        if (dateFormatObj._[dtKeys[i]]) {\n            o._[dtKeys[i]] = dateFormatObj._[dtKeys[i]];\n        }\n    }\n    for (var j = 0; j < tmKeys.length; j += 1) {\n        if (timeFormatObj[tmKeys[j]]) {\n            o[tmKeys[j]] = timeFormatObj[tmKeys[j]];\n        }\n        if (timeFormatObj._[tmKeys[j]]) {\n            o._[tmKeys[j]] = timeFormatObj._[tmKeys[j]];\n        }\n    }\n    return o;\n}\n\nfunction computeFinalPatterns(formatObj) {\n    // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n    //  'In patterns, two single quotes represents a literal single quote, either\n    //   inside or outside single quotes. Text within single quotes is not\n    //   interpreted in any way (except for two adjacent single quotes).'\n    formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, function ($0, literal) {\n        return literal ? literal : \"'\";\n    });\n\n    // pattern 12 is always the default. we can produce the 24 by removing {ampm}\n    formatObj.pattern = formatObj.pattern12.replace('{ampm}', '').replace(expPatternTrimmer, '');\n    return formatObj;\n}\n\nfunction expDTComponentsMeta($0, formatObj) {\n    switch ($0.charAt(0)) {\n        // --- Era\n        case 'G':\n            formatObj.era = ['short', 'short', 'short', 'long', 'narrow'][$0.length - 1];\n            return '{era}';\n\n        // --- Year\n        case 'y':\n        case 'Y':\n        case 'u':\n        case 'U':\n        case 'r':\n            formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{year}';\n\n        // --- Quarter (not supported in this polyfill)\n        case 'Q':\n        case 'q':\n            formatObj.quarter = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n            return '{quarter}';\n\n        // --- Month\n        case 'M':\n        case 'L':\n            formatObj.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n            return '{month}';\n\n        // --- Week (not supported in this polyfill)\n        case 'w':\n            // week of the year\n            formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{weekday}';\n        case 'W':\n            // week of the month\n            formatObj.week = 'numeric';\n            return '{weekday}';\n\n        // --- Day\n        case 'd':\n            // day of the month\n            formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{day}';\n        case 'D': // day of the year\n        case 'F': // day of the week\n        case 'g':\n            // 1..n: Modified Julian day\n            formatObj.day = 'numeric';\n            return '{day}';\n\n        // --- Week Day\n        case 'E':\n            // day of the week\n            formatObj.weekday = ['short', 'short', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n            return '{weekday}';\n        case 'e':\n            // local day of the week\n            formatObj.weekday = ['numeric', '2-digit', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n            return '{weekday}';\n        case 'c':\n            // stand alone local day of the week\n            formatObj.weekday = ['numeric', undefined, 'short', 'long', 'narrow', 'short'][$0.length - 1];\n            return '{weekday}';\n\n        // --- Period\n        case 'a': // AM, PM\n        case 'b': // am, pm, noon, midnight\n        case 'B':\n            // flexible day periods\n            formatObj.hour12 = true;\n            return '{ampm}';\n\n        // --- Hour\n        case 'h':\n        case 'H':\n            formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{hour}';\n        case 'k':\n        case 'K':\n            formatObj.hour12 = true; // 12-hour-cycle time formats (using h or K)\n            formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{hour}';\n\n        // --- Minute\n        case 'm':\n            formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{minute}';\n\n        // --- Second\n        case 's':\n            formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{second}';\n        case 'S':\n        case 'A':\n            formatObj.second = 'numeric';\n            return '{second}';\n\n        // --- Timezone\n        case 'z': // 1..3, 4: specific non-location format\n        case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n        case 'O': // 1, 4: miliseconds in day short, long\n        case 'v': // 1, 4: generic non-location format\n        case 'V': // 1, 2, 3, 4: time zone ID or city\n        case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n        case 'x':\n            // 1, 2, 3, 4: The ISO8601 varios formats\n            // this polyfill only supports much, for now, we are just doing something dummy\n            formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n            return '{timeZoneName}';\n    }\n}\n\n/**\n * Converts the CLDR availableFormats into the objects and patterns required by\n * the ECMAScript Internationalization API specification.\n */\nfunction createDateTimeFormat(skeleton, pattern) {\n    // we ignore certain patterns that are unsupported to avoid this expensive op.\n    if (unwantedDTCs.test(pattern)) return undefined;\n\n    var formatObj = {\n        originalPattern: pattern,\n        _: {}\n    };\n\n    // Replace the pattern string with the one required by the specification, whilst\n    // at the same time evaluating it for the subsets and formats\n    formatObj.extendedPattern = pattern.replace(expDTComponents, function ($0) {\n        // See which symbol we're dealing with\n        return expDTComponentsMeta($0, formatObj._);\n    });\n\n    // Match the skeleton string with the one required by the specification\n    // this implementation is based on the Date Field Symbol Table:\n    // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n    // Note: we are adding extra data to the formatObject even though this polyfill\n    //       might not support it.\n    skeleton.replace(expDTComponents, function ($0) {\n        // See which symbol we're dealing with\n        return expDTComponentsMeta($0, formatObj);\n    });\n\n    return computeFinalPatterns(formatObj);\n}\n\n/**\n * Processes DateTime formats from CLDR to an easier-to-parse format.\n * the result of this operation should be cached the first time a particular\n * calendar is analyzed.\n *\n * The specification requires we support at least the following subsets of\n * date/time components:\n *\n *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\n *   - 'weekday', 'year', 'month', 'day'\n *   - 'year', 'month', 'day'\n *   - 'year', 'month'\n *   - 'month', 'day'\n *   - 'hour', 'minute', 'second'\n *   - 'hour', 'minute'\n *\n * We need to cherry pick at least these subsets from the CLDR data and convert\n * them into the pattern objects used in the ECMA-402 API.\n */\nfunction createDateTimeFormats(formats) {\n    var availableFormats = formats.availableFormats;\n    var timeFormats = formats.timeFormats;\n    var dateFormats = formats.dateFormats;\n    var result = [];\n    var skeleton = void 0,\n        pattern = void 0,\n        computed = void 0,\n        i = void 0,\n        j = void 0;\n    var timeRelatedFormats = [];\n    var dateRelatedFormats = [];\n\n    // Map available (custom) formats into a pattern for createDateTimeFormats\n    for (skeleton in availableFormats) {\n        if (availableFormats.hasOwnProperty(skeleton)) {\n            pattern = availableFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                // in some cases, the format is only displaying date specific props\n                // or time specific props, in which case we need to also produce the\n                // combined formats.\n                if (isDateFormatOnly(computed)) {\n                    dateRelatedFormats.push(computed);\n                } else if (isTimeFormatOnly(computed)) {\n                    timeRelatedFormats.push(computed);\n                }\n            }\n        }\n    }\n\n    // Map time formats into a pattern for createDateTimeFormats\n    for (skeleton in timeFormats) {\n        if (timeFormats.hasOwnProperty(skeleton)) {\n            pattern = timeFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                timeRelatedFormats.push(computed);\n            }\n        }\n    }\n\n    // Map date formats into a pattern for createDateTimeFormats\n    for (skeleton in dateFormats) {\n        if (dateFormats.hasOwnProperty(skeleton)) {\n            pattern = dateFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                dateRelatedFormats.push(computed);\n            }\n        }\n    }\n\n    // combine custom time and custom date formats when they are orthogonals to complete the\n    // formats supported by CLDR.\n    // This Algo is based on section \"Missing Skeleton Fields\" from:\n    // http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n    for (i = 0; i < timeRelatedFormats.length; i += 1) {\n        for (j = 0; j < dateRelatedFormats.length; j += 1) {\n            if (dateRelatedFormats[j].month === 'long') {\n                pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;\n            } else if (dateRelatedFormats[j].month === 'short') {\n                pattern = formats.medium;\n            } else {\n                pattern = formats.short;\n            }\n            computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i]);\n            computed.originalPattern = pattern;\n            computed.extendedPattern = pattern.replace('{0}', timeRelatedFormats[i].extendedPattern).replace('{1}', dateRelatedFormats[j].extendedPattern).replace(/^[,\\s]+|[,\\s]+$/gi, '');\n            result.push(computeFinalPatterns(computed));\n        }\n    }\n\n    return result;\n}\n\n// this represents the exceptions of the rule that are not covered by CLDR availableFormats\n// for single property configurations, they play no role when using multiple properties, and\n// those that are not in this table, are not exceptions or are not covered by the data we\n// provide.\nvar validSyntheticProps = {\n    second: {\n        numeric: 's',\n        '2-digit': 'ss'\n    },\n    minute: {\n        numeric: 'm',\n        '2-digit': 'mm'\n    },\n    year: {\n        numeric: 'y',\n        '2-digit': 'yy'\n    },\n    day: {\n        numeric: 'd',\n        '2-digit': 'dd'\n    },\n    month: {\n        numeric: 'L',\n        '2-digit': 'LL',\n        narrow: 'LLLLL',\n        short: 'LLL',\n        long: 'LLLL'\n    },\n    weekday: {\n        narrow: 'ccccc',\n        short: 'ccc',\n        long: 'cccc'\n    }\n};\n\nfunction generateSyntheticFormat(propName, propValue) {\n    if (validSyntheticProps[propName] && validSyntheticProps[propName][propValue]) {\n        var _ref2;\n\n        return _ref2 = {\n            originalPattern: validSyntheticProps[propName][propValue],\n            _: defineProperty$1({}, propName, propValue),\n            extendedPattern: \"{\" + propName + \"}\"\n        }, defineProperty$1(_ref2, propName, propValue), defineProperty$1(_ref2, \"pattern12\", \"{\" + propName + \"}\"), defineProperty$1(_ref2, \"pattern\", \"{\" + propName + \"}\"), _ref2;\n    }\n}\n\n// An object map of date component keys, saves using a regex later\nvar dateWidths = objCreate(null, { narrow: {}, short: {}, long: {} });\n\n/**\n * Returns a string for a date component, resolved using multiple inheritance as specified\n * as specified in the Unicode Technical Standard 35.\n */\nfunction resolveDateString(data, ca, component, width, key) {\n    // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n    // 'In clearly specified instances, resources may inherit from within the same locale.\n    //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n    var obj = data[ca] && data[ca][component] ? data[ca][component] : data.gregory[component],\n\n\n    // \"sideways\" inheritance resolves strings when a key doesn't exist\n    alts = {\n        narrow: ['short', 'long'],\n        short: ['long', 'narrow'],\n        long: ['short', 'narrow']\n    },\n\n\n    //\n    resolved = hop.call(obj, width) ? obj[width] : hop.call(obj, alts[width][0]) ? obj[alts[width][0]] : obj[alts[width][1]];\n\n    // `key` wouldn't be specified for components 'dayPeriods'\n    return key !== null ? resolved[key] : resolved;\n}\n\n// Define the DateTimeFormat constructor internally so it cannot be tainted\nfunction DateTimeFormatConstructor() {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.DateTimeFormat(locales, options);\n    }\n    return InitializeDateTimeFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'DateTimeFormat', {\n    configurable: true,\n    writable: true,\n    value: DateTimeFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(DateTimeFormatConstructor, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n * DateTimeFormat object.\n */\nfunction /* 12.1.1.1 */InitializeDateTimeFormat(dateTimeFormat, locales, options) {\n    // This will be a internal properties object if we're not already initialized\n    var internal = getInternalProperties(dateTimeFormat);\n\n    // Create an object whose props can be used to restore the values of RegExp props\n    var regexpRestore = createRegExpRestore();\n\n    // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n    //    value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(dateTimeFormat, '__getInternalProperties', {\n        value: function value() {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret) return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    var requestedLocales = CanonicalizeLocaleList(locales);\n\n    // 4. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined below) with arguments options, \"any\", and \"date\".\n    options = ToDateTimeOptions(options, 'any', 'date');\n\n    // 5. Let opt be a new Record.\n    var opt = new Record();\n\n    // 6. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n    //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n    var matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 7. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    // 8. Let DateTimeFormat be the standard built-in object that is the initial\n    //    value of Intl.DateTimeFormat.\n    var DateTimeFormat = internals.DateTimeFormat; // This is what we *really* need\n\n    // 9. Let localeData be the value of the [[localeData]] internal property of\n    //    DateTimeFormat.\n    var localeData = DateTimeFormat['[[localeData]]'];\n\n    // 10. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //      internal property of DateTimeFormat, and localeData.\n    var r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales, opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\n\n    // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n    //     r.[[ca]].\n    internal['[[calendar]]'] = r['[[ca]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n    //     r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n    var dataLocale = r['[[dataLocale]]'];\n\n    // 15. Let tz be the result of calling the [[Get]] internal method of options with\n    //     argument \"timeZone\".\n    var tz = options.timeZone;\n\n    // 16. If tz is not undefined, then\n    if (tz !== undefined) {\n        // a. Let tz be ToString(tz).\n        // b. Convert tz to upper case as described in 6.1.\n        //    NOTE: If an implementation accepts additional time zone values, as permitted\n        //          under certain conditions by the Conformance clause, different casing\n        //          rules apply.\n        tz = toLatinUpperCase(tz);\n\n        // c. If tz is not \"UTC\", then throw a RangeError exception.\n        // ###TODO: accept more time zones###\n        if (tz !== 'UTC') throw new RangeError('timeZone is not supported.');\n    }\n\n    // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n    internal['[[timeZone]]'] = tz;\n\n    // 18. Let opt be a new Record.\n    opt = new Record();\n\n    // 19. For each row of Table 3, except the header row, do:\n    for (var prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop)) continue;\n\n        // 20. Let prop be the name given in the Property column of the row.\n        // 21. Let value be the result of calling the GetOption abstract operation,\n        //     passing as argument options, the name given in the Property column of the\n        //     row, \"string\", a List containing the strings given in the Values column of\n        //     the row, and undefined.\n        var value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\n\n        // 22. Set opt.[[<prop>]] to value.\n        opt['[[' + prop + ']]'] = value;\n    }\n\n    // Assigned a value below\n    var bestFormat = void 0;\n\n    // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n    //     localeData with argument dataLocale.\n    var dataLocaleData = localeData[dataLocale];\n\n    // 24. Let formats be the result of calling the [[Get]] internal method of\n    //     dataLocaleData with argument \"formats\".\n    //     Note: we process the CLDR formats into the spec'd structure\n    var formats = ToDateTimeFormats(dataLocaleData.formats);\n\n    // 25. Let matcher be the result of calling the GetOption abstract operation with\n    //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n    //     values \"basic\" and \"best fit\", and \"best fit\".\n    matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\n\n    // Optimization: caching the processed formats as a one time operation by\n    // replacing the initial structure from localeData\n    dataLocaleData.formats = formats;\n\n    // 26. If matcher is \"basic\", then\n    if (matcher === 'basic') {\n        // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n        //     operation (defined below) with opt and formats.\n        bestFormat = BasicFormatMatcher(opt, formats);\n\n        // 28. Else\n    } else {\n        {\n            // diverging\n            var _hr = GetOption(options, 'hour12', 'boolean' /*, undefined, undefined*/);\n            opt.hour12 = _hr === undefined ? dataLocaleData.hour12 : _hr;\n        }\n        // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n        //     abstract operation (defined below) with opt and formats.\n        bestFormat = BestFitFormatMatcher(opt, formats);\n    }\n\n    // 30. For each row in Table 3, except the header row, do\n    for (var _prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, _prop)) continue;\n\n        // a. Let prop be the name given in the Property column of the row.\n        // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n        //    bestFormat with argument prop.\n        // c. If pDesc is not undefined, then\n        if (hop.call(bestFormat, _prop)) {\n            // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n            //    with argument prop.\n            var p = bestFormat[_prop];\n            {\n                // diverging\n                p = bestFormat._ && hop.call(bestFormat._, _prop) ? bestFormat._[_prop] : p;\n            }\n\n            // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n            internal['[[' + _prop + ']]'] = p;\n        }\n    }\n\n    var pattern = void 0; // Assigned a value below\n\n    // 31. Let hr12 be the result of calling the GetOption abstract operation with\n    //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n    var hr12 = GetOption(options, 'hour12', 'boolean' /*, undefined, undefined*/);\n\n    // 32. If dateTimeFormat has an internal property [[hour]], then\n    if (internal['[[hour]]']) {\n        // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n        //    internal method of dataLocaleData with argument \"hour12\".\n        hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\n\n        // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n        internal['[[hour12]]'] = hr12;\n\n        // c. If hr12 is true, then\n        if (hr12 === true) {\n            // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n            //    dataLocaleData with argument \"hourNo0\".\n            var hourNo0 = dataLocaleData.hourNo0;\n\n            // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n            internal['[[hourNo0]]'] = hourNo0;\n\n            // iii. Let pattern be the result of calling the [[Get]] internal method of\n            //      bestFormat with argument \"pattern12\".\n            pattern = bestFormat.pattern12;\n        }\n\n        // d. Else\n        else\n            // i. Let pattern be the result of calling the [[Get]] internal method of\n            //    bestFormat with argument \"pattern\".\n            pattern = bestFormat.pattern;\n    }\n\n    // 33. Else\n    else\n        // a. Let pattern be the result of calling the [[Get]] internal method of\n        //    bestFormat with argument \"pattern\".\n        pattern = bestFormat.pattern;\n\n    // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n    internal['[[pattern]]'] = pattern;\n\n    // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n    //     true.\n    internal['[[initializedDateTimeFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3) dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\n\n    // Restore the RegExp properties\n    regexpRestore();\n\n    // Return the newly initialised object\n    return dateTimeFormat;\n}\n\n/**\n * Several DateTimeFormat algorithms use values from the following table, which provides\n * property names and allowable values for the components of date and time formats:\n */\nvar dateTimeComponents = {\n    weekday: [\"narrow\", \"short\", \"long\"],\n    era: [\"narrow\", \"short\", \"long\"],\n    year: [\"2-digit\", \"numeric\"],\n    month: [\"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\"],\n    day: [\"2-digit\", \"numeric\"],\n    hour: [\"2-digit\", \"numeric\"],\n    minute: [\"2-digit\", \"numeric\"],\n    second: [\"2-digit\", \"numeric\"],\n    timeZoneName: [\"short\", \"long\"]\n};\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeFormats(formats) {\n    if (Object.prototype.toString.call(formats) === '[object Array]') {\n        return formats;\n    }\n    return createDateTimeFormats(formats);\n}\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeOptions(options, required, defaults) {\n    // 1. If options is undefined, then let options be null, else let options be\n    //    ToObject(options).\n    if (options === undefined) options = null;else {\n        // (#12) options needs to be a Record, but it also needs to inherit properties\n        var opt2 = toObject(options);\n        options = new Record();\n\n        for (var k in opt2) {\n            options[k] = opt2[k];\n        }\n    }\n\n    // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n    var create = objCreate;\n\n    // 3. Let options be the result of calling the [[Call]] internal method of create with\n    //    undefined as the this value and an argument list containing the single item\n    //    options.\n    options = create(options);\n\n    // 4. Let needDefaults be true.\n    var needDefaults = true;\n\n    // 5. If required is \"date\" or \"any\", then\n    if (required === 'date' || required === 'any') {\n        // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n        // i. If the result of calling the [[Get]] internal method of options with the\n        //    property name is not undefined, then let needDefaults be false.\n        if (options.weekday !== undefined || options.year !== undefined || options.month !== undefined || options.day !== undefined) needDefaults = false;\n    }\n\n    // 6. If required is \"time\" or \"any\", then\n    if (required === 'time' || required === 'any') {\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n        // i. If the result of calling the [[Get]] internal method of options with the\n        //    property name is not undefined, then let needDefaults be false.\n        if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined) needDefaults = false;\n    }\n\n    // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n    if (needDefaults && (defaults === 'date' || defaults === 'all'))\n        // a. For each of the property names \"year\", \"month\", \"day\":\n        // i. Call the [[DefineOwnProperty]] internal method of options with the\n        //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n        //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.year = options.month = options.day = 'numeric';\n\n    // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n    if (needDefaults && (defaults === 'time' || defaults === 'all'))\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n        // i. Call the [[DefineOwnProperty]] internal method of options with the\n        //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n        //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.hour = options.minute = options.second = 'numeric';\n\n    // 9. Return options.\n    return options;\n}\n\n/**\n * When the BasicFormatMatcher abstract operation is called with two arguments options and\n * formats, the following steps are taken:\n */\nfunction BasicFormatMatcher(options, formats) {\n    // 1. Let removalPenalty be 120.\n    var removalPenalty = 120;\n\n    // 2. Let additionPenalty be 20.\n    var additionPenalty = 20;\n\n    // 3. Let longLessPenalty be 8.\n    var longLessPenalty = 8;\n\n    // 4. Let longMorePenalty be 6.\n    var longMorePenalty = 6;\n\n    // 5. Let shortLessPenalty be 6.\n    var shortLessPenalty = 6;\n\n    // 6. Let shortMorePenalty be 3.\n    var shortMorePenalty = 3;\n\n    // 7. Let bestScore be -Infinity.\n    var bestScore = -Infinity;\n\n    // 8. Let bestFormat be undefined.\n    var bestFormat = void 0;\n\n    // 9. Let i be 0.\n    var i = 0;\n\n    // 10. Assert: formats is an Array object.\n\n    // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n    var len = formats.length;\n\n    // 12. Repeat while i < len:\n    while (i < len) {\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n        var format = formats[i];\n\n        // b. Let score be 0.\n        var score = 0;\n\n        // c. For each property shown in Table 3:\n        for (var property in dateTimeComponents) {\n            if (!hop.call(dateTimeComponents, property)) continue;\n\n            // i. Let optionsProp be options.[[<property>]].\n            var optionsProp = options['[[' + property + ']]'];\n\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n            //     with argument property.\n            // iii. If formatPropDesc is not undefined, then\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n            var formatProp = hop.call(format, property) ? format[property] : undefined;\n\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n            //     additionPenalty.\n            if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty;\n\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n            //    removalPenalty.\n            else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty;\n\n                // vi. Else\n                else {\n                        // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                        //    \"long\"].\n                        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n\n                        // 2. Let optionsPropIndex be the index of optionsProp within values.\n                        var optionsPropIndex = arrIndexOf.call(values, optionsProp);\n\n                        // 3. Let formatPropIndex be the index of formatProp within values.\n                        var formatPropIndex = arrIndexOf.call(values, formatProp);\n\n                        // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                        var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                        // 5. If delta = 2, decrease score by longMorePenalty.\n                        if (delta === 2) score -= longMorePenalty;\n\n                        // 6. Else if delta = 1, decrease score by shortMorePenalty.\n                        else if (delta === 1) score -= shortMorePenalty;\n\n                            // 7. Else if delta = -1, decrease score by shortLessPenalty.\n                            else if (delta === -1) score -= shortLessPenalty;\n\n                                // 8. Else if delta = -2, decrease score by longLessPenalty.\n                                else if (delta === -2) score -= longLessPenalty;\n                    }\n        }\n\n        // d. If score > bestScore, then\n        if (score > bestScore) {\n            // i. Let bestScore be score.\n            bestScore = score;\n\n            // ii. Let bestFormat be format.\n            bestFormat = format;\n        }\n\n        // e. Increase i by 1.\n        i++;\n    }\n\n    // 13. Return bestFormat.\n    return bestFormat;\n}\n\n/**\n * When the BestFitFormatMatcher abstract operation is called with two arguments options\n * and formats, it performs implementation dependent steps, which should return a set of\n * component representations that a typical user of the selected locale would perceive as\n * at least as good as the one returned by BasicFormatMatcher.\n *\n * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n * with the addition of bonus points awarded where the requested format is of\n * the same data type as the potentially matching format.\n *\n * This algo relies on the concept of closest distance matching described here:\n * http://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n * Typically a “best match” is found using a closest distance match, such as:\n *\n * Symbols requesting a best choice for the locale are replaced.\n *      j → one of {H, k, h, K}; C → one of {a, b, B}\n * -> Covered by cldr.js matching process\n *\n * For fields with symbols representing the same type (year, month, day, etc):\n *     Most symbols have a small distance from each other.\n *         M ≅ L; E ≅ c; a ≅ b ≅ B; H ≅ k ≅ h ≅ K; ...\n *     -> Covered by cldr.js matching process\n *\n *     Width differences among fields, other than those marking text vs numeric, are given small distance from each other.\n *         MMM ≅ MMMM\n *         MM ≅ M\n *     Numeric and text fields are given a larger distance from each other.\n *         MMM ≈ MM\n *     Symbols representing substantial differences (week of year vs week of month) are given much larger a distances from each other.\n *         d ≋ D; ...\n *     Missing or extra fields cause a match to fail. (But see Missing Skeleton Fields).\n *\n *\n * For example,\n *\n *     { month: 'numeric', day: 'numeric' }\n *\n * should match\n *\n *     { month: '2-digit', day: '2-digit' }\n *\n * rather than\n *\n *     { month: 'short', day: 'numeric' }\n *\n * This makes sense because a user requesting a formatted date with numeric parts would\n * not expect to see the returned format containing narrow, short or long part names\n */\nfunction BestFitFormatMatcher(options, formats) {\n    /** Diverging: this block implements the hack for single property configuration, eg.:\n     *\n     *      `new Intl.DateTimeFormat('en', {day: 'numeric'})`\n     *\n     * should produce a single digit with the day of the month. This is needed because\n     * CLDR `availableFormats` data structure doesn't cover these cases.\n     */\n    {\n        var optionsPropNames = [];\n        for (var property in dateTimeComponents) {\n            if (!hop.call(dateTimeComponents, property)) continue;\n\n            if (options['[[' + property + ']]'] !== undefined) {\n                optionsPropNames.push(property);\n            }\n        }\n        if (optionsPropNames.length === 1) {\n            var _bestFormat = generateSyntheticFormat(optionsPropNames[0], options['[[' + optionsPropNames[0] + ']]']);\n            if (_bestFormat) {\n                return _bestFormat;\n            }\n        }\n    }\n\n    // 1. Let removalPenalty be 120.\n    var removalPenalty = 120;\n\n    // 2. Let additionPenalty be 20.\n    var additionPenalty = 20;\n\n    // 3. Let longLessPenalty be 8.\n    var longLessPenalty = 8;\n\n    // 4. Let longMorePenalty be 6.\n    var longMorePenalty = 6;\n\n    // 5. Let shortLessPenalty be 6.\n    var shortLessPenalty = 6;\n\n    // 6. Let shortMorePenalty be 3.\n    var shortMorePenalty = 3;\n\n    var patternPenalty = 2;\n\n    var hour12Penalty = 1;\n\n    // 7. Let bestScore be -Infinity.\n    var bestScore = -Infinity;\n\n    // 8. Let bestFormat be undefined.\n    var bestFormat = void 0;\n\n    // 9. Let i be 0.\n    var i = 0;\n\n    // 10. Assert: formats is an Array object.\n\n    // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n    var len = formats.length;\n\n    // 12. Repeat while i < len:\n    while (i < len) {\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n        var format = formats[i];\n\n        // b. Let score be 0.\n        var score = 0;\n\n        // c. For each property shown in Table 3:\n        for (var _property in dateTimeComponents) {\n            if (!hop.call(dateTimeComponents, _property)) continue;\n\n            // i. Let optionsProp be options.[[<property>]].\n            var optionsProp = options['[[' + _property + ']]'];\n\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n            //     with argument property.\n            // iii. If formatPropDesc is not undefined, then\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n            var formatProp = hop.call(format, _property) ? format[_property] : undefined;\n\n            // Diverging: using the default properties produced by the pattern/skeleton\n            // to match it with user options, and apply a penalty\n            var patternProp = hop.call(format._, _property) ? format._[_property] : undefined;\n            if (optionsProp !== patternProp) {\n                score -= patternPenalty;\n            }\n\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n            //     additionPenalty.\n            if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty;\n\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n            //    removalPenalty.\n            else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty;\n\n                // vi. Else\n                else {\n                        // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                        //    \"long\"].\n                        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n\n                        // 2. Let optionsPropIndex be the index of optionsProp within values.\n                        var optionsPropIndex = arrIndexOf.call(values, optionsProp);\n\n                        // 3. Let formatPropIndex be the index of formatProp within values.\n                        var formatPropIndex = arrIndexOf.call(values, formatProp);\n\n                        // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                        var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                        {\n                            // diverging from spec\n                            // When the bestFit argument is true, subtract additional penalty where data types are not the same\n                            if (formatPropIndex <= 1 && optionsPropIndex >= 2 || formatPropIndex >= 2 && optionsPropIndex <= 1) {\n                                // 5. If delta = 2, decrease score by longMorePenalty.\n                                if (delta > 0) score -= longMorePenalty;else if (delta < 0) score -= longLessPenalty;\n                            } else {\n                                // 5. If delta = 2, decrease score by longMorePenalty.\n                                if (delta > 1) score -= shortMorePenalty;else if (delta < -1) score -= shortLessPenalty;\n                            }\n                        }\n                    }\n        }\n\n        {\n            // diverging to also take into consideration differences between 12 or 24 hours\n            // which is special for the best fit only.\n            if (format._.hour12 !== options.hour12) {\n                score -= hour12Penalty;\n            }\n        }\n\n        // d. If score > bestScore, then\n        if (score > bestScore) {\n            // i. Let bestScore be score.\n            bestScore = score;\n            // ii. Let bestFormat be format.\n            bestFormat = format;\n        }\n\n        // e. Increase i by 1.\n        i++;\n    }\n\n    // 13. Return bestFormat.\n    return bestFormat;\n}\n\n/* 12.2.3 */internals.DateTimeFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['ca', 'nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n * following steps are taken:\n */\n/* 12.2.2 */\ndefineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(function (locales) {\n        // Bound functions only have the `this` value altered if being used as a constructor,\n        // this lets us imitate a native function that has no constructor\n        if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor');\n\n        // Create an object whose props can be used to restore the values of RegExp props\n        var regexpRestore = createRegExpRestore(),\n\n\n        // 1. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n        //    property of the standard built-in object that is the initial value of\n        //    Intl.NumberFormat.\n\n        availableLocales = this['[[availableLocales]]'],\n\n\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n        //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n        // Restore the RegExp properties\n        regexpRestore();\n\n        // 4. Return the result of calling the SupportedLocales abstract operation\n        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n        //    and options.\n        return SupportedLocales(availableLocales, requestedLocales, options);\n    }, internals.NumberFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * DateTimeFormat object.\n */\n/* 12.3.2 */defineProperty(Intl.DateTimeFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatDateTime\n});\n\nfunction GetFormatDateTime() {\n    var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n    // Satisfy test 12.3_b\n    if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\n\n    // The value of the [[Get]] attribute is a function that takes the following\n    // steps:\n\n    // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n    //    is undefined, then:\n    if (internal['[[boundFormat]]'] === undefined) {\n        // a. Let F be a Function object, with internal properties set as\n        //    specified for built-in functions in ES5, 15, or successor, and the\n        //    length property set to 0, that takes the argument date and\n        //    performs the following steps:\n        var F = function F() {\n            var date = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n\n            //   i. If date is not provided or is undefined, then let x be the\n            //      result as if by the expression Date.now() where Date.now is\n            //      the standard built-in function defined in ES5, 15.9.4.4.\n            //  ii. Else let x be ToNumber(date).\n            // iii. Return the result of calling the FormatDateTime abstract\n            //      operation (defined below) with arguments this and x.\n            var x = date === undefined ? Date.now() : toNumber(date);\n            return FormatDateTime(this, x);\n        };\n        // b. Let bind be the standard built-in function object defined in ES5,\n        //    15.3.4.5.\n        // c. Let bf be the result of calling the [[Call]] internal method of\n        //    bind with F as the this value and an argument list containing\n        //    the single item this.\n        var bf = fnBind.call(F, this);\n        // d. Set the [[boundFormat]] internal property of this NumberFormat\n        //    object to bf.\n        internal['[[boundFormat]]'] = bf;\n    }\n    // Return the value of the [[boundFormat]] internal property of this\n    // NumberFormat object.\n    return internal['[[boundFormat]]'];\n}\n\nfunction formatToParts$1() {\n    var date = arguments.length <= 0 || arguments[0] === undefined ? undefined : arguments[0];\n\n    var internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n    if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.DateTimeFormat object.');\n\n    var x = date === undefined ? Date.now() : toNumber(date);\n    return FormatToPartsDateTime(this, x);\n}\n\nObject.defineProperty(Intl.DateTimeFormat.prototype, 'formatToParts', {\n    enumerable: false,\n    writable: true,\n    configurable: true,\n    value: formatToParts$1\n});\n\nfunction CreateDateTimeParts(dateTimeFormat, x) {\n    // 1. If x is not a finite Number, then throw a RangeError exception.\n    if (!isFinite(x)) throw new RangeError('Invalid valid date passed to format');\n\n    var internal = dateTimeFormat.__getInternalProperties(secret);\n\n    // Creating restore point for properties on the RegExp object... please wait\n    /* let regexpRestore = */createRegExpRestore(); // ###TODO: review this\n\n    // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n    var locale = internal['[[locale]]'];\n\n    // 3. Let nf be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n    // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n    var nf = new Intl.NumberFormat([locale], { useGrouping: false });\n\n    // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n    // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n    // 11.1.3.\n    var nf2 = new Intl.NumberFormat([locale], { minimumIntegerDigits: 2, useGrouping: false });\n\n    // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n    // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n    // and the value of the [[timeZone]] internal property of dateTimeFormat.\n    var tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']);\n\n    // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n    var pattern = internal['[[pattern]]'];\n\n    // 7.\n    var result = new List();\n\n    // 8.\n    var index = 0;\n\n    // 9.\n    var beginIndex = pattern.indexOf('{');\n\n    // 10.\n    var endIndex = 0;\n\n    // Need the locale minus any extensions\n    var dataLocale = internal['[[dataLocale]]'];\n\n    // Need the calendar data from CLDR\n    var localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars;\n    var ca = internal['[[calendar]]'];\n\n    // 11.\n    while (beginIndex !== -1) {\n        var fv = void 0;\n        // a.\n        endIndex = pattern.indexOf('}', beginIndex);\n        // b.\n        if (endIndex === -1) {\n            throw new Error('Unclosed pattern');\n        }\n        // c.\n        if (beginIndex > index) {\n            arrPush.call(result, {\n                type: 'literal',\n                value: pattern.substring(index, beginIndex)\n            });\n        }\n        // d.\n        var p = pattern.substring(beginIndex + 1, endIndex);\n        // e.\n        if (dateTimeComponents.hasOwnProperty(p)) {\n            //   i. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n            var f = internal['[[' + p + ']]'];\n            //  ii. Let v be the value of tm.[[<p>]].\n            var v = tm['[[' + p + ']]'];\n            // iii. If p is \"year\" and v ≤ 0, then let v be 1 - v.\n            if (p === 'year' && v <= 0) {\n                v = 1 - v;\n            }\n            //  iv. If p is \"month\", then increase v by 1.\n            else if (p === 'month') {\n                    v++;\n                }\n                //   v. If p is \"hour\" and the value of the [[hour12]] internal property of\n                //      dateTimeFormat is true, then\n                else if (p === 'hour' && internal['[[hour12]]'] === true) {\n                        // 1. Let v be v modulo 12.\n                        v = v % 12;\n                        // 2. If v is 0 and the value of the [[hourNo0]] internal property of\n                        //    dateTimeFormat is true, then let v be 12.\n                        if (v === 0 && internal['[[hourNo0]]'] === true) {\n                            v = 12;\n                        }\n                    }\n\n            //  vi. If f is \"numeric\", then\n            if (f === 'numeric') {\n                // 1. Let fv be the result of calling the FormatNumber abstract operation\n                //    (defined in 11.3.2) with arguments nf and v.\n                fv = FormatNumber(nf, v);\n            }\n            // vii. Else if f is \"2-digit\", then\n            else if (f === '2-digit') {\n                    // 1. Let fv be the result of calling the FormatNumber abstract operation\n                    //    with arguments nf2 and v.\n                    fv = FormatNumber(nf2, v);\n                    // 2. If the length of fv is greater than 2, let fv be the substring of fv\n                    //    containing the last two characters.\n                    if (fv.length > 2) {\n                        fv = fv.slice(-2);\n                    }\n                }\n                // viii. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n                //     value representing f in the desired form; the String value depends upon\n                //     the implementation and the effective locale and calendar of\n                //     dateTimeFormat. If p is \"month\", then the String value may also depend\n                //     on whether dateTimeFormat has a [[day]] internal property. If p is\n                //     \"timeZoneName\", then the String value may also depend on the value of\n                //     the [[inDST]] field of tm.\n                else if (f in dateWidths) {\n                        switch (p) {\n                            case 'month':\n                                fv = resolveDateString(localeData, ca, 'months', f, tm['[[' + p + ']]']);\n                                break;\n\n                            case 'weekday':\n                                try {\n                                    fv = resolveDateString(localeData, ca, 'days', f, tm['[[' + p + ']]']);\n                                    // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n                                } catch (e) {\n                                    throw new Error('Could not find weekday data for locale ' + locale);\n                                }\n                                break;\n\n                            case 'timeZoneName':\n                                fv = ''; // ###TODO\n                                break;\n\n                            case 'era':\n                                try {\n                                    fv = resolveDateString(localeData, ca, 'eras', f, tm['[[' + p + ']]']);\n                                } catch (e) {\n                                    throw new Error('Could not find era data for locale ' + locale);\n                                }\n                                break;\n\n                            default:\n                                fv = tm['[[' + p + ']]'];\n                        }\n                    }\n            // ix\n            arrPush.call(result, {\n                type: p,\n                value: fv\n            });\n            // f.\n        } else if (p === 'ampm') {\n            // i.\n            var _v = tm['[[hour]]'];\n            // ii./iii.\n            fv = resolveDateString(localeData, ca, 'dayPeriods', _v > 11 ? 'pm' : 'am', null);\n            // iv.\n            arrPush.call(result, {\n                type: 'dayPeriod',\n                value: fv\n            });\n            // g.\n        } else {\n            arrPush.call(result, {\n                type: 'literal',\n                value: pattern.substring(beginIndex, endIndex + 1)\n            });\n        }\n        // h.\n        index = endIndex + 1;\n        // i.\n        beginIndex = pattern.indexOf('{', index);\n    }\n    // 12.\n    if (endIndex < pattern.length - 1) {\n        arrPush.call(result, {\n            type: 'literal',\n            value: pattern.substr(endIndex + 1)\n        });\n    }\n    // 13.\n    return result;\n}\n\n/**\n * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n * value), it returns a String value representing x (interpreted as a time value as\n * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n * options of dateTimeFormat.\n */\nfunction FormatDateTime(dateTimeFormat, x) {\n    var parts = CreateDateTimeParts(dateTimeFormat, x);\n    var result = '';\n\n    for (var i = 0; parts.length > i; i++) {\n        var part = parts[i];\n        result += part.value;\n    }\n    return result;\n}\n\nfunction FormatToPartsDateTime(dateTimeFormat, x) {\n    var parts = CreateDateTimeParts(dateTimeFormat, x);\n    var result = [];\n    for (var i = 0; parts.length > i; i++) {\n        var part = parts[i];\n        result.push({\n            type: part.type,\n            value: part.value\n        });\n    }\n    return result;\n}\n\n/**\n * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n * timeZone, the following steps are taken:\n */\nfunction ToLocalTime(date, calendar, timeZone) {\n    // 1. Apply calendrical calculations on date for the given calendar and time zone to\n    //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n    //    The calculations should use best available information about the specified\n    //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n    //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n    //    bound by the restrictions on the use of best available information on time zones\n    //    for local time zone adjustment and daylight saving time adjustment imposed by\n    //    ES5, 15.9.1.7 and 15.9.1.8.\n    // ###TODO###\n    var d = new Date(date),\n        m = 'get' + (timeZone || '');\n\n    // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n    //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n    //    calculated value.\n    return new Record({\n        '[[weekday]]': d[m + 'Day'](),\n        '[[era]]': +(d[m + 'FullYear']() >= 0),\n        '[[year]]': d[m + 'FullYear'](),\n        '[[month]]': d[m + 'Month'](),\n        '[[day]]': d[m + 'Date'](),\n        '[[hour]]': d[m + 'Hours'](),\n        '[[minute]]': d[m + 'Minutes'](),\n        '[[second]]': d[m + 'Seconds'](),\n        '[[inDST]]': false // ###TODO###\n    });\n}\n\n/**\n * The function returns a new object whose properties and attributes are set as if\n * constructed by an object literal assigning to each of the following properties the\n * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n * properties are not present are not assigned.\n */\n/* 12.3.3 */defineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n    writable: true,\n    configurable: true,\n    value: function value() {\n        var prop = void 0,\n            descs = new Record(),\n            props = ['locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'],\n            internal = this !== null && babelHelpers$1[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n        // Satisfy test 12.3_b\n        if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\nvar ls = Intl.__localeSensitiveProtos = {\n    Number: {},\n    Date: {}\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.2.1 */ls.Number.toLocaleString = function () {\n    // Satisfy test 13.2.1_1\n    if (Object.prototype.toString.call(this) !== '[object Number]') throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\n\n    // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n    // 2. If locales is not provided, then let locales be undefined.\n    // 3. If options is not provided, then let options be undefined.\n    // 4. Let numberFormat be the result of creating a new object as if by the\n    //    expression new Intl.NumberFormat(locales, options) where\n    //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n    // 5. Return the result of calling the FormatNumber abstract operation\n    //    (defined in 11.3.2) with arguments numberFormat and x.\n    return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.3.1 */ls.Date.toLocaleString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\n\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n    var x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x)) return 'Invalid Date';\n\n    // 3. If locales is not provided, then let locales be undefined.\n    var locales = arguments[0];\n\n    // 4. If options is not provided, then let options be undefined.\n    var options = arguments[1];\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n    options = ToDateTimeOptions(options, 'any', 'all');\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n    var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleDateString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.2 */ls.Date.toLocaleDateString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\n\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n    var x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x)) return 'Invalid Date';\n\n    // 3. If locales is not provided, then let locales be undefined.\n    var locales = arguments[0],\n\n\n    // 4. If options is not provided, then let options be undefined.\n    options = arguments[1];\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n    options = ToDateTimeOptions(options, 'date', 'date');\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n    var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleTimeString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.3 */ls.Date.toLocaleTimeString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\n\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n    var x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x)) return 'Invalid Date';\n\n    // 3. If locales is not provided, then let locales be undefined.\n    var locales = arguments[0];\n\n    // 4. If options is not provided, then let options be undefined.\n    var options = arguments[1];\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n    options = ToDateTimeOptions(options, 'time', 'time');\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n    var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\ndefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n    writable: true,\n    configurable: true,\n    value: function value() {\n        defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\n        // Need this here for IE 8, to avoid the _DontEnum_ bug\n        defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\n\n        for (var k in ls.Date) {\n            if (hop.call(ls.Date, k)) defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\n        }\n    }\n});\n\n/**\n * Can't really ship a single script with data for hundreds of locales, so we provide\n * this __addLocaleData method as a means for the developer to add the data on an\n * as-needed basis\n */\ndefineProperty(Intl, '__addLocaleData', {\n    value: function value(data) {\n        if (!IsStructurallyValidLanguageTag(data.locale)) throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n\n        addLocaleData(data, data.locale);\n    }\n});\n\nfunction addLocaleData(data, tag) {\n    // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n    if (!data.number) throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n\n    var locale = void 0,\n        locales = [tag],\n        parts = tag.split('-');\n\n    // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n    if (parts.length > 2 && parts[1].length === 4) arrPush.call(locales, parts[0] + '-' + parts[2]);\n\n    while (locale = arrShift.call(locales)) {\n        // Add to NumberFormat internal properties as per 11.2.3\n        arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n        internals.NumberFormat['[[localeData]]'][locale] = data.number;\n\n        // ...and DateTimeFormat internal properties as per 12.2.3\n        if (data.date) {\n            data.date.nu = data.number.nu;\n            arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n            internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n        }\n    }\n\n    // If this is the first set of locale data added, make it the default\n    if (defaultLocale === undefined) setDefaultLocale(tag);\n}\n\ndefineProperty(Intl, '__disableRegExpRestore', {\n    value: function value() {\n        internals.disableRegExpRestore = true;\n    }\n});\n\nmodule.exports = Intl;"]},"metadata":{},"sourceType":"script"}